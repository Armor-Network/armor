// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages-bytecoin.proto

#ifndef PROTOBUF_INCLUDED_messages_2dbytecoin_2eproto
#define PROTOBUF_INCLUDED_messages_2dbytecoin_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_messages_2dbytecoin_2eproto 

namespace protobuf_messages_2dbytecoin_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[25];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_messages_2dbytecoin_2eproto
namespace hw {
namespace trezor {
namespace messages {
namespace bytecoin {
class BytecoinEmptyResponse;
class BytecoinEmptyResponseDefaultTypeInternal;
extern BytecoinEmptyResponseDefaultTypeInternal _BytecoinEmptyResponse_default_instance_;
class BytecoinExportViewWalletRequest;
class BytecoinExportViewWalletRequestDefaultTypeInternal;
extern BytecoinExportViewWalletRequestDefaultTypeInternal _BytecoinExportViewWalletRequest_default_instance_;
class BytecoinExportViewWalletResponse;
class BytecoinExportViewWalletResponseDefaultTypeInternal;
extern BytecoinExportViewWalletResponseDefaultTypeInternal _BytecoinExportViewWalletResponse_default_instance_;
class BytecoinGenerateKeyimageRequest;
class BytecoinGenerateKeyimageRequestDefaultTypeInternal;
extern BytecoinGenerateKeyimageRequestDefaultTypeInternal _BytecoinGenerateKeyimageRequest_default_instance_;
class BytecoinGenerateKeyimageResponse;
class BytecoinGenerateKeyimageResponseDefaultTypeInternal;
extern BytecoinGenerateKeyimageResponseDefaultTypeInternal _BytecoinGenerateKeyimageResponse_default_instance_;
class BytecoinGenerateOutputSeedRequest;
class BytecoinGenerateOutputSeedRequestDefaultTypeInternal;
extern BytecoinGenerateOutputSeedRequestDefaultTypeInternal _BytecoinGenerateOutputSeedRequest_default_instance_;
class BytecoinGenerateOutputSeedResponse;
class BytecoinGenerateOutputSeedResponseDefaultTypeInternal;
extern BytecoinGenerateOutputSeedResponseDefaultTypeInternal _BytecoinGenerateOutputSeedResponse_default_instance_;
class BytecoinProofMoreDataRequest;
class BytecoinProofMoreDataRequestDefaultTypeInternal;
extern BytecoinProofMoreDataRequestDefaultTypeInternal _BytecoinProofMoreDataRequest_default_instance_;
class BytecoinScanOutputsRequest;
class BytecoinScanOutputsRequestDefaultTypeInternal;
extern BytecoinScanOutputsRequestDefaultTypeInternal _BytecoinScanOutputsRequest_default_instance_;
class BytecoinScanOutputsResponse;
class BytecoinScanOutputsResponseDefaultTypeInternal;
extern BytecoinScanOutputsResponseDefaultTypeInternal _BytecoinScanOutputsResponse_default_instance_;
class BytecoinSignAddExtraRequest;
class BytecoinSignAddExtraRequestDefaultTypeInternal;
extern BytecoinSignAddExtraRequestDefaultTypeInternal _BytecoinSignAddExtraRequest_default_instance_;
class BytecoinSignAddInputRequest;
class BytecoinSignAddInputRequestDefaultTypeInternal;
extern BytecoinSignAddInputRequestDefaultTypeInternal _BytecoinSignAddInputRequest_default_instance_;
class BytecoinSignAddOutputRequest;
class BytecoinSignAddOutputRequestDefaultTypeInternal;
extern BytecoinSignAddOutputRequestDefaultTypeInternal _BytecoinSignAddOutputRequest_default_instance_;
class BytecoinSignAddOutputResponse;
class BytecoinSignAddOutputResponseDefaultTypeInternal;
extern BytecoinSignAddOutputResponseDefaultTypeInternal _BytecoinSignAddOutputResponse_default_instance_;
class BytecoinSignGetC0Request;
class BytecoinSignGetC0RequestDefaultTypeInternal;
extern BytecoinSignGetC0RequestDefaultTypeInternal _BytecoinSignGetC0Request_default_instance_;
class BytecoinSignGetC0Response;
class BytecoinSignGetC0ResponseDefaultTypeInternal;
extern BytecoinSignGetC0ResponseDefaultTypeInternal _BytecoinSignGetC0Response_default_instance_;
class BytecoinSignStartRequest;
class BytecoinSignStartRequestDefaultTypeInternal;
extern BytecoinSignStartRequestDefaultTypeInternal _BytecoinSignStartRequest_default_instance_;
class BytecoinSignStepAMoreDataRequest;
class BytecoinSignStepAMoreDataRequestDefaultTypeInternal;
extern BytecoinSignStepAMoreDataRequestDefaultTypeInternal _BytecoinSignStepAMoreDataRequest_default_instance_;
class BytecoinSignStepARequest;
class BytecoinSignStepARequestDefaultTypeInternal;
extern BytecoinSignStepARequestDefaultTypeInternal _BytecoinSignStepARequest_default_instance_;
class BytecoinSignStepAResponse;
class BytecoinSignStepAResponseDefaultTypeInternal;
extern BytecoinSignStepAResponseDefaultTypeInternal _BytecoinSignStepAResponse_default_instance_;
class BytecoinSignStepBRequest;
class BytecoinSignStepBRequestDefaultTypeInternal;
extern BytecoinSignStepBRequestDefaultTypeInternal _BytecoinSignStepBRequest_default_instance_;
class BytecoinSignStepBResponse;
class BytecoinSignStepBResponseDefaultTypeInternal;
extern BytecoinSignStepBResponseDefaultTypeInternal _BytecoinSignStepBResponse_default_instance_;
class BytecoinStartProofRequest;
class BytecoinStartProofRequestDefaultTypeInternal;
extern BytecoinStartProofRequestDefaultTypeInternal _BytecoinStartProofRequest_default_instance_;
class BytecoinStartRequest;
class BytecoinStartRequestDefaultTypeInternal;
extern BytecoinStartRequestDefaultTypeInternal _BytecoinStartRequest_default_instance_;
class BytecoinStartResponse;
class BytecoinStartResponseDefaultTypeInternal;
extern BytecoinStartResponseDefaultTypeInternal _BytecoinStartResponse_default_instance_;
}  // namespace bytecoin
}  // namespace messages
}  // namespace trezor
}  // namespace hw
namespace google {
namespace protobuf {
template<> ::hw::trezor::messages::bytecoin::BytecoinEmptyResponse* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinEmptyResponse>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinExportViewWalletRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinExportViewWalletRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinExportViewWalletResponse* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinExportViewWalletResponse>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinGenerateKeyimageRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinGenerateKeyimageRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinGenerateKeyimageResponse* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinGenerateKeyimageResponse>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinGenerateOutputSeedRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinGenerateOutputSeedRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinGenerateOutputSeedResponse* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinGenerateOutputSeedResponse>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinProofMoreDataRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinProofMoreDataRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinScanOutputsRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinScanOutputsRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinScanOutputsResponse* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinScanOutputsResponse>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinSignAddExtraRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinSignAddExtraRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinSignAddInputRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinSignAddInputRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinSignAddOutputRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinSignAddOutputRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinSignAddOutputResponse* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinSignAddOutputResponse>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinSignGetC0Request* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinSignGetC0Request>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinSignGetC0Response* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinSignGetC0Response>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinSignStartRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinSignStartRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinSignStepAMoreDataRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinSignStepAMoreDataRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinSignStepARequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinSignStepARequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinSignStepAResponse* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinSignStepAResponse>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinSignStepBRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinSignStepBRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinSignStepBResponse* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinSignStepBResponse>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinStartProofRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinStartProofRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinStartRequest* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinStartRequest>(Arena*);
template<> ::hw::trezor::messages::bytecoin::BytecoinStartResponse* Arena::CreateMaybeMessage<::hw::trezor::messages::bytecoin::BytecoinStartResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hw {
namespace trezor {
namespace messages {
namespace bytecoin {

// ===================================================================

class BytecoinStartRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinStartRequest) */ {
 public:
  BytecoinStartRequest();
  virtual ~BytecoinStartRequest();

  BytecoinStartRequest(const BytecoinStartRequest& from);

  inline BytecoinStartRequest& operator=(const BytecoinStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinStartRequest(BytecoinStartRequest&& from) noexcept
    : BytecoinStartRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinStartRequest& operator=(BytecoinStartRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinStartRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinStartRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinStartRequest*>(
               &_BytecoinStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(BytecoinStartRequest* other);
  friend void swap(BytecoinStartRequest& a, BytecoinStartRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinStartRequest* New() const final {
    return CreateMaybeMessage<BytecoinStartRequest>(NULL);
  }

  BytecoinStartRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinStartRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinStartRequest& from);
  void MergeFrom(const BytecoinStartRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinStartRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes debug_request = 1;
  bool has_debug_request() const;
  void clear_debug_request();
  static const int kDebugRequestFieldNumber = 1;
  const ::std::string& debug_request() const;
  void set_debug_request(const ::std::string& value);
  #if LANG_CXX11
  void set_debug_request(::std::string&& value);
  #endif
  void set_debug_request(const char* value);
  void set_debug_request(const void* value, size_t size);
  ::std::string* mutable_debug_request();
  ::std::string* release_debug_request();
  void set_allocated_debug_request(::std::string* debug_request);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinStartRequest)
 private:
  void set_has_debug_request();
  void clear_has_debug_request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr debug_request_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinStartResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinStartResponse) */ {
 public:
  BytecoinStartResponse();
  virtual ~BytecoinStartResponse();

  BytecoinStartResponse(const BytecoinStartResponse& from);

  inline BytecoinStartResponse& operator=(const BytecoinStartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinStartResponse(BytecoinStartResponse&& from) noexcept
    : BytecoinStartResponse() {
    *this = ::std::move(from);
  }

  inline BytecoinStartResponse& operator=(BytecoinStartResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinStartResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinStartResponse* internal_default_instance() {
    return reinterpret_cast<const BytecoinStartResponse*>(
               &_BytecoinStartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BytecoinStartResponse* other);
  friend void swap(BytecoinStartResponse& a, BytecoinStartResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinStartResponse* New() const final {
    return CreateMaybeMessage<BytecoinStartResponse>(NULL);
  }

  BytecoinStartResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinStartResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinStartResponse& from);
  void MergeFrom(const BytecoinStartResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinStartResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes wallet_key = 1;
  bool has_wallet_key() const;
  void clear_wallet_key();
  static const int kWalletKeyFieldNumber = 1;
  const ::std::string& wallet_key() const;
  void set_wallet_key(const ::std::string& value);
  #if LANG_CXX11
  void set_wallet_key(::std::string&& value);
  #endif
  void set_wallet_key(const char* value);
  void set_wallet_key(const void* value, size_t size);
  ::std::string* mutable_wallet_key();
  ::std::string* release_wallet_key();
  void set_allocated_wallet_key(::std::string* wallet_key);

  // optional bytes A_plus_sH = 2;
  bool has_a_plus_sh() const;
  void clear_a_plus_sh();
  static const int kAPlusSHFieldNumber = 2;
  const ::std::string& a_plus_sh() const;
  void set_a_plus_sh(const ::std::string& value);
  #if LANG_CXX11
  void set_a_plus_sh(::std::string&& value);
  #endif
  void set_a_plus_sh(const char* value);
  void set_a_plus_sh(const void* value, size_t size);
  ::std::string* mutable_a_plus_sh();
  ::std::string* release_a_plus_sh();
  void set_allocated_a_plus_sh(::std::string* a_plus_sh);

  // optional bytes v_mul_A_plus_sH = 3;
  bool has_v_mul_a_plus_sh() const;
  void clear_v_mul_a_plus_sh();
  static const int kVMulAPlusSHFieldNumber = 3;
  const ::std::string& v_mul_a_plus_sh() const;
  void set_v_mul_a_plus_sh(const ::std::string& value);
  #if LANG_CXX11
  void set_v_mul_a_plus_sh(::std::string&& value);
  #endif
  void set_v_mul_a_plus_sh(const char* value);
  void set_v_mul_a_plus_sh(const void* value, size_t size);
  ::std::string* mutable_v_mul_a_plus_sh();
  ::std::string* release_v_mul_a_plus_sh();
  void set_allocated_v_mul_a_plus_sh(::std::string* v_mul_a_plus_sh);

  // optional bytes view_public_key = 4;
  bool has_view_public_key() const;
  void clear_view_public_key();
  static const int kViewPublicKeyFieldNumber = 4;
  const ::std::string& view_public_key() const;
  void set_view_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_view_public_key(::std::string&& value);
  #endif
  void set_view_public_key(const char* value);
  void set_view_public_key(const void* value, size_t size);
  ::std::string* mutable_view_public_key();
  ::std::string* release_view_public_key();
  void set_allocated_view_public_key(::std::string* view_public_key);

  // optional bytes debug_response = 5;
  bool has_debug_response() const;
  void clear_debug_response();
  static const int kDebugResponseFieldNumber = 5;
  const ::std::string& debug_response() const;
  void set_debug_response(const ::std::string& value);
  #if LANG_CXX11
  void set_debug_response(::std::string&& value);
  #endif
  void set_debug_response(const char* value);
  void set_debug_response(const void* value, size_t size);
  ::std::string* mutable_debug_response();
  ::std::string* release_debug_response();
  void set_allocated_debug_response(::std::string* debug_response);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinStartResponse)
 private:
  void set_has_wallet_key();
  void clear_has_wallet_key();
  void set_has_a_plus_sh();
  void clear_has_a_plus_sh();
  void set_has_v_mul_a_plus_sh();
  void clear_has_v_mul_a_plus_sh();
  void set_has_view_public_key();
  void clear_has_view_public_key();
  void set_has_debug_response();
  void clear_has_debug_response();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr wallet_key_;
  ::google::protobuf::internal::ArenaStringPtr a_plus_sh_;
  ::google::protobuf::internal::ArenaStringPtr v_mul_a_plus_sh_;
  ::google::protobuf::internal::ArenaStringPtr view_public_key_;
  ::google::protobuf::internal::ArenaStringPtr debug_response_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinScanOutputsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest) */ {
 public:
  BytecoinScanOutputsRequest();
  virtual ~BytecoinScanOutputsRequest();

  BytecoinScanOutputsRequest(const BytecoinScanOutputsRequest& from);

  inline BytecoinScanOutputsRequest& operator=(const BytecoinScanOutputsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinScanOutputsRequest(BytecoinScanOutputsRequest&& from) noexcept
    : BytecoinScanOutputsRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinScanOutputsRequest& operator=(BytecoinScanOutputsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinScanOutputsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinScanOutputsRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinScanOutputsRequest*>(
               &_BytecoinScanOutputsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(BytecoinScanOutputsRequest* other);
  friend void swap(BytecoinScanOutputsRequest& a, BytecoinScanOutputsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinScanOutputsRequest* New() const final {
    return CreateMaybeMessage<BytecoinScanOutputsRequest>(NULL);
  }

  BytecoinScanOutputsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinScanOutputsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinScanOutputsRequest& from);
  void MergeFrom(const BytecoinScanOutputsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinScanOutputsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes output_public_key = 1;
  int output_public_key_size() const;
  void clear_output_public_key();
  static const int kOutputPublicKeyFieldNumber = 1;
  const ::std::string& output_public_key(int index) const;
  ::std::string* mutable_output_public_key(int index);
  void set_output_public_key(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_output_public_key(int index, ::std::string&& value);
  #endif
  void set_output_public_key(int index, const char* value);
  void set_output_public_key(int index, const void* value, size_t size);
  ::std::string* add_output_public_key();
  void add_output_public_key(const ::std::string& value);
  #if LANG_CXX11
  void add_output_public_key(::std::string&& value);
  #endif
  void add_output_public_key(const char* value);
  void add_output_public_key(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& output_public_key() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_output_public_key();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> output_public_key_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinScanOutputsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse) */ {
 public:
  BytecoinScanOutputsResponse();
  virtual ~BytecoinScanOutputsResponse();

  BytecoinScanOutputsResponse(const BytecoinScanOutputsResponse& from);

  inline BytecoinScanOutputsResponse& operator=(const BytecoinScanOutputsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinScanOutputsResponse(BytecoinScanOutputsResponse&& from) noexcept
    : BytecoinScanOutputsResponse() {
    *this = ::std::move(from);
  }

  inline BytecoinScanOutputsResponse& operator=(BytecoinScanOutputsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinScanOutputsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinScanOutputsResponse* internal_default_instance() {
    return reinterpret_cast<const BytecoinScanOutputsResponse*>(
               &_BytecoinScanOutputsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BytecoinScanOutputsResponse* other);
  friend void swap(BytecoinScanOutputsResponse& a, BytecoinScanOutputsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinScanOutputsResponse* New() const final {
    return CreateMaybeMessage<BytecoinScanOutputsResponse>(NULL);
  }

  BytecoinScanOutputsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinScanOutputsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinScanOutputsResponse& from);
  void MergeFrom(const BytecoinScanOutputsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinScanOutputsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes Pv = 1;
  int pv_size() const;
  void clear_pv();
  static const int kPvFieldNumber = 1;
  const ::std::string& pv(int index) const;
  ::std::string* mutable_pv(int index);
  void set_pv(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_pv(int index, ::std::string&& value);
  #endif
  void set_pv(int index, const char* value);
  void set_pv(int index, const void* value, size_t size);
  ::std::string* add_pv();
  void add_pv(const ::std::string& value);
  #if LANG_CXX11
  void add_pv(::std::string&& value);
  #endif
  void add_pv(const char* value);
  void add_pv(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& pv() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pv();

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pv_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinGenerateKeyimageRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest) */ {
 public:
  BytecoinGenerateKeyimageRequest();
  virtual ~BytecoinGenerateKeyimageRequest();

  BytecoinGenerateKeyimageRequest(const BytecoinGenerateKeyimageRequest& from);

  inline BytecoinGenerateKeyimageRequest& operator=(const BytecoinGenerateKeyimageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinGenerateKeyimageRequest(BytecoinGenerateKeyimageRequest&& from) noexcept
    : BytecoinGenerateKeyimageRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinGenerateKeyimageRequest& operator=(BytecoinGenerateKeyimageRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinGenerateKeyimageRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinGenerateKeyimageRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinGenerateKeyimageRequest*>(
               &_BytecoinGenerateKeyimageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BytecoinGenerateKeyimageRequest* other);
  friend void swap(BytecoinGenerateKeyimageRequest& a, BytecoinGenerateKeyimageRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinGenerateKeyimageRequest* New() const final {
    return CreateMaybeMessage<BytecoinGenerateKeyimageRequest>(NULL);
  }

  BytecoinGenerateKeyimageRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinGenerateKeyimageRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinGenerateKeyimageRequest& from);
  void MergeFrom(const BytecoinGenerateKeyimageRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinGenerateKeyimageRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes output_public_key = 1;
  bool has_output_public_key() const;
  void clear_output_public_key();
  static const int kOutputPublicKeyFieldNumber = 1;
  const ::std::string& output_public_key() const;
  void set_output_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_output_public_key(::std::string&& value);
  #endif
  void set_output_public_key(const char* value);
  void set_output_public_key(const void* value, size_t size);
  ::std::string* mutable_output_public_key();
  ::std::string* release_output_public_key();
  void set_allocated_output_public_key(::std::string* output_public_key);

  // optional bytes inv_output_main_hash = 2;
  bool has_inv_output_main_hash() const;
  void clear_inv_output_main_hash();
  static const int kInvOutputMainHashFieldNumber = 2;
  const ::std::string& inv_output_main_hash() const;
  void set_inv_output_main_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_inv_output_main_hash(::std::string&& value);
  #endif
  void set_inv_output_main_hash(const char* value);
  void set_inv_output_main_hash(const void* value, size_t size);
  ::std::string* mutable_inv_output_main_hash();
  ::std::string* release_inv_output_main_hash();
  void set_allocated_inv_output_main_hash(::std::string* inv_output_main_hash);

  // optional uint32 address_index = 3;
  bool has_address_index() const;
  void clear_address_index();
  static const int kAddressIndexFieldNumber = 3;
  ::google::protobuf::uint32 address_index() const;
  void set_address_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest)
 private:
  void set_has_output_public_key();
  void clear_has_output_public_key();
  void set_has_inv_output_main_hash();
  void clear_has_inv_output_main_hash();
  void set_has_address_index();
  void clear_has_address_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr output_public_key_;
  ::google::protobuf::internal::ArenaStringPtr inv_output_main_hash_;
  ::google::protobuf::uint32 address_index_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinGenerateKeyimageResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageResponse) */ {
 public:
  BytecoinGenerateKeyimageResponse();
  virtual ~BytecoinGenerateKeyimageResponse();

  BytecoinGenerateKeyimageResponse(const BytecoinGenerateKeyimageResponse& from);

  inline BytecoinGenerateKeyimageResponse& operator=(const BytecoinGenerateKeyimageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinGenerateKeyimageResponse(BytecoinGenerateKeyimageResponse&& from) noexcept
    : BytecoinGenerateKeyimageResponse() {
    *this = ::std::move(from);
  }

  inline BytecoinGenerateKeyimageResponse& operator=(BytecoinGenerateKeyimageResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinGenerateKeyimageResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinGenerateKeyimageResponse* internal_default_instance() {
    return reinterpret_cast<const BytecoinGenerateKeyimageResponse*>(
               &_BytecoinGenerateKeyimageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BytecoinGenerateKeyimageResponse* other);
  friend void swap(BytecoinGenerateKeyimageResponse& a, BytecoinGenerateKeyimageResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinGenerateKeyimageResponse* New() const final {
    return CreateMaybeMessage<BytecoinGenerateKeyimageResponse>(NULL);
  }

  BytecoinGenerateKeyimageResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinGenerateKeyimageResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinGenerateKeyimageResponse& from);
  void MergeFrom(const BytecoinGenerateKeyimageResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinGenerateKeyimageResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes keyimage = 1;
  bool has_keyimage() const;
  void clear_keyimage();
  static const int kKeyimageFieldNumber = 1;
  const ::std::string& keyimage() const;
  void set_keyimage(const ::std::string& value);
  #if LANG_CXX11
  void set_keyimage(::std::string&& value);
  #endif
  void set_keyimage(const char* value);
  void set_keyimage(const void* value, size_t size);
  ::std::string* mutable_keyimage();
  ::std::string* release_keyimage();
  void set_allocated_keyimage(::std::string* keyimage);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageResponse)
 private:
  void set_has_keyimage();
  void clear_has_keyimage();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr keyimage_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinGenerateOutputSeedRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedRequest) */ {
 public:
  BytecoinGenerateOutputSeedRequest();
  virtual ~BytecoinGenerateOutputSeedRequest();

  BytecoinGenerateOutputSeedRequest(const BytecoinGenerateOutputSeedRequest& from);

  inline BytecoinGenerateOutputSeedRequest& operator=(const BytecoinGenerateOutputSeedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinGenerateOutputSeedRequest(BytecoinGenerateOutputSeedRequest&& from) noexcept
    : BytecoinGenerateOutputSeedRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinGenerateOutputSeedRequest& operator=(BytecoinGenerateOutputSeedRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinGenerateOutputSeedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinGenerateOutputSeedRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinGenerateOutputSeedRequest*>(
               &_BytecoinGenerateOutputSeedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(BytecoinGenerateOutputSeedRequest* other);
  friend void swap(BytecoinGenerateOutputSeedRequest& a, BytecoinGenerateOutputSeedRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinGenerateOutputSeedRequest* New() const final {
    return CreateMaybeMessage<BytecoinGenerateOutputSeedRequest>(NULL);
  }

  BytecoinGenerateOutputSeedRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinGenerateOutputSeedRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinGenerateOutputSeedRequest& from);
  void MergeFrom(const BytecoinGenerateOutputSeedRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinGenerateOutputSeedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes tx_inputs_hash = 1;
  bool has_tx_inputs_hash() const;
  void clear_tx_inputs_hash();
  static const int kTxInputsHashFieldNumber = 1;
  const ::std::string& tx_inputs_hash() const;
  void set_tx_inputs_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_inputs_hash(::std::string&& value);
  #endif
  void set_tx_inputs_hash(const char* value);
  void set_tx_inputs_hash(const void* value, size_t size);
  ::std::string* mutable_tx_inputs_hash();
  ::std::string* release_tx_inputs_hash();
  void set_allocated_tx_inputs_hash(::std::string* tx_inputs_hash);

  // optional uint32 out_index = 3;
  bool has_out_index() const;
  void clear_out_index();
  static const int kOutIndexFieldNumber = 3;
  ::google::protobuf::uint32 out_index() const;
  void set_out_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedRequest)
 private:
  void set_has_tx_inputs_hash();
  void clear_has_tx_inputs_hash();
  void set_has_out_index();
  void clear_has_out_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tx_inputs_hash_;
  ::google::protobuf::uint32 out_index_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinGenerateOutputSeedResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedResponse) */ {
 public:
  BytecoinGenerateOutputSeedResponse();
  virtual ~BytecoinGenerateOutputSeedResponse();

  BytecoinGenerateOutputSeedResponse(const BytecoinGenerateOutputSeedResponse& from);

  inline BytecoinGenerateOutputSeedResponse& operator=(const BytecoinGenerateOutputSeedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinGenerateOutputSeedResponse(BytecoinGenerateOutputSeedResponse&& from) noexcept
    : BytecoinGenerateOutputSeedResponse() {
    *this = ::std::move(from);
  }

  inline BytecoinGenerateOutputSeedResponse& operator=(BytecoinGenerateOutputSeedResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinGenerateOutputSeedResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinGenerateOutputSeedResponse* internal_default_instance() {
    return reinterpret_cast<const BytecoinGenerateOutputSeedResponse*>(
               &_BytecoinGenerateOutputSeedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(BytecoinGenerateOutputSeedResponse* other);
  friend void swap(BytecoinGenerateOutputSeedResponse& a, BytecoinGenerateOutputSeedResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinGenerateOutputSeedResponse* New() const final {
    return CreateMaybeMessage<BytecoinGenerateOutputSeedResponse>(NULL);
  }

  BytecoinGenerateOutputSeedResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinGenerateOutputSeedResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinGenerateOutputSeedResponse& from);
  void MergeFrom(const BytecoinGenerateOutputSeedResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinGenerateOutputSeedResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes output_seed = 1;
  bool has_output_seed() const;
  void clear_output_seed();
  static const int kOutputSeedFieldNumber = 1;
  const ::std::string& output_seed() const;
  void set_output_seed(const ::std::string& value);
  #if LANG_CXX11
  void set_output_seed(::std::string&& value);
  #endif
  void set_output_seed(const char* value);
  void set_output_seed(const void* value, size_t size);
  ::std::string* mutable_output_seed();
  ::std::string* release_output_seed();
  void set_allocated_output_seed(::std::string* output_seed);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedResponse)
 private:
  void set_has_output_seed();
  void clear_has_output_seed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr output_seed_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinExportViewWalletRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinExportViewWalletRequest) */ {
 public:
  BytecoinExportViewWalletRequest();
  virtual ~BytecoinExportViewWalletRequest();

  BytecoinExportViewWalletRequest(const BytecoinExportViewWalletRequest& from);

  inline BytecoinExportViewWalletRequest& operator=(const BytecoinExportViewWalletRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinExportViewWalletRequest(BytecoinExportViewWalletRequest&& from) noexcept
    : BytecoinExportViewWalletRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinExportViewWalletRequest& operator=(BytecoinExportViewWalletRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinExportViewWalletRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinExportViewWalletRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinExportViewWalletRequest*>(
               &_BytecoinExportViewWalletRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(BytecoinExportViewWalletRequest* other);
  friend void swap(BytecoinExportViewWalletRequest& a, BytecoinExportViewWalletRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinExportViewWalletRequest* New() const final {
    return CreateMaybeMessage<BytecoinExportViewWalletRequest>(NULL);
  }

  BytecoinExportViewWalletRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinExportViewWalletRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinExportViewWalletRequest& from);
  void MergeFrom(const BytecoinExportViewWalletRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinExportViewWalletRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinExportViewWalletRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinExportViewWalletResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse) */ {
 public:
  BytecoinExportViewWalletResponse();
  virtual ~BytecoinExportViewWalletResponse();

  BytecoinExportViewWalletResponse(const BytecoinExportViewWalletResponse& from);

  inline BytecoinExportViewWalletResponse& operator=(const BytecoinExportViewWalletResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinExportViewWalletResponse(BytecoinExportViewWalletResponse&& from) noexcept
    : BytecoinExportViewWalletResponse() {
    *this = ::std::move(from);
  }

  inline BytecoinExportViewWalletResponse& operator=(BytecoinExportViewWalletResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinExportViewWalletResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinExportViewWalletResponse* internal_default_instance() {
    return reinterpret_cast<const BytecoinExportViewWalletResponse*>(
               &_BytecoinExportViewWalletResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(BytecoinExportViewWalletResponse* other);
  friend void swap(BytecoinExportViewWalletResponse& a, BytecoinExportViewWalletResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinExportViewWalletResponse* New() const final {
    return CreateMaybeMessage<BytecoinExportViewWalletResponse>(NULL);
  }

  BytecoinExportViewWalletResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinExportViewWalletResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinExportViewWalletResponse& from);
  void MergeFrom(const BytecoinExportViewWalletResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinExportViewWalletResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes audit_key_base_secret_key = 1;
  bool has_audit_key_base_secret_key() const;
  void clear_audit_key_base_secret_key();
  static const int kAuditKeyBaseSecretKeyFieldNumber = 1;
  const ::std::string& audit_key_base_secret_key() const;
  void set_audit_key_base_secret_key(const ::std::string& value);
  #if LANG_CXX11
  void set_audit_key_base_secret_key(::std::string&& value);
  #endif
  void set_audit_key_base_secret_key(const char* value);
  void set_audit_key_base_secret_key(const void* value, size_t size);
  ::std::string* mutable_audit_key_base_secret_key();
  ::std::string* release_audit_key_base_secret_key();
  void set_allocated_audit_key_base_secret_key(::std::string* audit_key_base_secret_key);

  // optional bytes view_secret_key = 2;
  bool has_view_secret_key() const;
  void clear_view_secret_key();
  static const int kViewSecretKeyFieldNumber = 2;
  const ::std::string& view_secret_key() const;
  void set_view_secret_key(const ::std::string& value);
  #if LANG_CXX11
  void set_view_secret_key(::std::string&& value);
  #endif
  void set_view_secret_key(const char* value);
  void set_view_secret_key(const void* value, size_t size);
  ::std::string* mutable_view_secret_key();
  ::std::string* release_view_secret_key();
  void set_allocated_view_secret_key(::std::string* view_secret_key);

  // optional bytes tx_derivation_seed = 3;
  bool has_tx_derivation_seed() const;
  void clear_tx_derivation_seed();
  static const int kTxDerivationSeedFieldNumber = 3;
  const ::std::string& tx_derivation_seed() const;
  void set_tx_derivation_seed(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_derivation_seed(::std::string&& value);
  #endif
  void set_tx_derivation_seed(const char* value);
  void set_tx_derivation_seed(const void* value, size_t size);
  ::std::string* mutable_tx_derivation_seed();
  ::std::string* release_tx_derivation_seed();
  void set_allocated_tx_derivation_seed(::std::string* tx_derivation_seed);

  // optional bytes view_secrets_signature = 4;
  bool has_view_secrets_signature() const;
  void clear_view_secrets_signature();
  static const int kViewSecretsSignatureFieldNumber = 4;
  const ::std::string& view_secrets_signature() const;
  void set_view_secrets_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_view_secrets_signature(::std::string&& value);
  #endif
  void set_view_secrets_signature(const char* value);
  void set_view_secrets_signature(const void* value, size_t size);
  ::std::string* mutable_view_secrets_signature();
  ::std::string* release_view_secrets_signature();
  void set_allocated_view_secrets_signature(::std::string* view_secrets_signature);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse)
 private:
  void set_has_audit_key_base_secret_key();
  void clear_has_audit_key_base_secret_key();
  void set_has_view_secret_key();
  void clear_has_view_secret_key();
  void set_has_tx_derivation_seed();
  void clear_has_tx_derivation_seed();
  void set_has_view_secrets_signature();
  void clear_has_view_secrets_signature();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr audit_key_base_secret_key_;
  ::google::protobuf::internal::ArenaStringPtr view_secret_key_;
  ::google::protobuf::internal::ArenaStringPtr tx_derivation_seed_;
  ::google::protobuf::internal::ArenaStringPtr view_secrets_signature_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinSignStartRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinSignStartRequest) */ {
 public:
  BytecoinSignStartRequest();
  virtual ~BytecoinSignStartRequest();

  BytecoinSignStartRequest(const BytecoinSignStartRequest& from);

  inline BytecoinSignStartRequest& operator=(const BytecoinSignStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinSignStartRequest(BytecoinSignStartRequest&& from) noexcept
    : BytecoinSignStartRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinSignStartRequest& operator=(BytecoinSignStartRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinSignStartRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinSignStartRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinSignStartRequest*>(
               &_BytecoinSignStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(BytecoinSignStartRequest* other);
  friend void swap(BytecoinSignStartRequest& a, BytecoinSignStartRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinSignStartRequest* New() const final {
    return CreateMaybeMessage<BytecoinSignStartRequest>(NULL);
  }

  BytecoinSignStartRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinSignStartRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinSignStartRequest& from);
  void MergeFrom(const BytecoinSignStartRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinSignStartRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ut = 2;
  bool has_ut() const;
  void clear_ut();
  static const int kUtFieldNumber = 2;
  ::google::protobuf::uint64 ut() const;
  void set_ut(::google::protobuf::uint64 value);

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional uint32 inputs_size = 3;
  bool has_inputs_size() const;
  void clear_inputs_size();
  static const int kInputsSizeFieldNumber = 3;
  ::google::protobuf::uint32 inputs_size() const;
  void set_inputs_size(::google::protobuf::uint32 value);

  // optional uint32 outputs_size = 4;
  bool has_outputs_size() const;
  void clear_outputs_size();
  static const int kOutputsSizeFieldNumber = 4;
  ::google::protobuf::uint32 outputs_size() const;
  void set_outputs_size(::google::protobuf::uint32 value);

  // optional uint32 extra_size = 5;
  bool has_extra_size() const;
  void clear_extra_size();
  static const int kExtraSizeFieldNumber = 5;
  ::google::protobuf::uint32 extra_size() const;
  void set_extra_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinSignStartRequest)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_ut();
  void clear_has_ut();
  void set_has_inputs_size();
  void clear_has_inputs_size();
  void set_has_outputs_size();
  void clear_has_outputs_size();
  void set_has_extra_size();
  void clear_has_extra_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 ut_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 inputs_size_;
  ::google::protobuf::uint32 outputs_size_;
  ::google::protobuf::uint32 extra_size_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinEmptyResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinEmptyResponse) */ {
 public:
  BytecoinEmptyResponse();
  virtual ~BytecoinEmptyResponse();

  BytecoinEmptyResponse(const BytecoinEmptyResponse& from);

  inline BytecoinEmptyResponse& operator=(const BytecoinEmptyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinEmptyResponse(BytecoinEmptyResponse&& from) noexcept
    : BytecoinEmptyResponse() {
    *this = ::std::move(from);
  }

  inline BytecoinEmptyResponse& operator=(BytecoinEmptyResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinEmptyResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinEmptyResponse* internal_default_instance() {
    return reinterpret_cast<const BytecoinEmptyResponse*>(
               &_BytecoinEmptyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(BytecoinEmptyResponse* other);
  friend void swap(BytecoinEmptyResponse& a, BytecoinEmptyResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinEmptyResponse* New() const final {
    return CreateMaybeMessage<BytecoinEmptyResponse>(NULL);
  }

  BytecoinEmptyResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinEmptyResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinEmptyResponse& from);
  void MergeFrom(const BytecoinEmptyResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinEmptyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinEmptyResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinSignAddInputRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest) */ {
 public:
  BytecoinSignAddInputRequest();
  virtual ~BytecoinSignAddInputRequest();

  BytecoinSignAddInputRequest(const BytecoinSignAddInputRequest& from);

  inline BytecoinSignAddInputRequest& operator=(const BytecoinSignAddInputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinSignAddInputRequest(BytecoinSignAddInputRequest&& from) noexcept
    : BytecoinSignAddInputRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinSignAddInputRequest& operator=(BytecoinSignAddInputRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinSignAddInputRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinSignAddInputRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinSignAddInputRequest*>(
               &_BytecoinSignAddInputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(BytecoinSignAddInputRequest* other);
  friend void swap(BytecoinSignAddInputRequest& a, BytecoinSignAddInputRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinSignAddInputRequest* New() const final {
    return CreateMaybeMessage<BytecoinSignAddInputRequest>(NULL);
  }

  BytecoinSignAddInputRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinSignAddInputRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinSignAddInputRequest& from);
  void MergeFrom(const BytecoinSignAddInputRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinSignAddInputRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 output_indexes = 2;
  int output_indexes_size() const;
  void clear_output_indexes();
  static const int kOutputIndexesFieldNumber = 2;
  ::google::protobuf::uint32 output_indexes(int index) const;
  void set_output_indexes(int index, ::google::protobuf::uint32 value);
  void add_output_indexes(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      output_indexes() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_output_indexes();

  // optional bytes inv_output_main_hash = 3;
  bool has_inv_output_main_hash() const;
  void clear_inv_output_main_hash();
  static const int kInvOutputMainHashFieldNumber = 3;
  const ::std::string& inv_output_main_hash() const;
  void set_inv_output_main_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_inv_output_main_hash(::std::string&& value);
  #endif
  void set_inv_output_main_hash(const char* value);
  void set_inv_output_main_hash(const void* value, size_t size);
  ::std::string* mutable_inv_output_main_hash();
  ::std::string* release_inv_output_main_hash();
  void set_allocated_inv_output_main_hash(::std::string* inv_output_main_hash);

  // optional uint64 amount = 1;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint32 address_index = 4;
  bool has_address_index() const;
  void clear_address_index();
  static const int kAddressIndexFieldNumber = 4;
  ::google::protobuf::uint32 address_index() const;
  void set_address_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest)
 private:
  void set_has_amount();
  void clear_has_amount();
  void set_has_inv_output_main_hash();
  void clear_has_inv_output_main_hash();
  void set_has_address_index();
  void clear_has_address_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > output_indexes_;
  ::google::protobuf::internal::ArenaStringPtr inv_output_main_hash_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 address_index_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinSignAddOutputRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest) */ {
 public:
  BytecoinSignAddOutputRequest();
  virtual ~BytecoinSignAddOutputRequest();

  BytecoinSignAddOutputRequest(const BytecoinSignAddOutputRequest& from);

  inline BytecoinSignAddOutputRequest& operator=(const BytecoinSignAddOutputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinSignAddOutputRequest(BytecoinSignAddOutputRequest&& from) noexcept
    : BytecoinSignAddOutputRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinSignAddOutputRequest& operator=(BytecoinSignAddOutputRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinSignAddOutputRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinSignAddOutputRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinSignAddOutputRequest*>(
               &_BytecoinSignAddOutputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(BytecoinSignAddOutputRequest* other);
  friend void swap(BytecoinSignAddOutputRequest& a, BytecoinSignAddOutputRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinSignAddOutputRequest* New() const final {
    return CreateMaybeMessage<BytecoinSignAddOutputRequest>(NULL);
  }

  BytecoinSignAddOutputRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinSignAddOutputRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinSignAddOutputRequest& from);
  void MergeFrom(const BytecoinSignAddOutputRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinSignAddOutputRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes dst_address_S = 4;
  bool has_dst_address_s() const;
  void clear_dst_address_s();
  static const int kDstAddressSFieldNumber = 4;
  const ::std::string& dst_address_s() const;
  void set_dst_address_s(const ::std::string& value);
  #if LANG_CXX11
  void set_dst_address_s(::std::string&& value);
  #endif
  void set_dst_address_s(const char* value);
  void set_dst_address_s(const void* value, size_t size);
  ::std::string* mutable_dst_address_s();
  ::std::string* release_dst_address_s();
  void set_allocated_dst_address_s(::std::string* dst_address_s);

  // optional bytes dst_address_Sv = 5;
  bool has_dst_address_sv() const;
  void clear_dst_address_sv();
  static const int kDstAddressSvFieldNumber = 5;
  const ::std::string& dst_address_sv() const;
  void set_dst_address_sv(const ::std::string& value);
  #if LANG_CXX11
  void set_dst_address_sv(::std::string&& value);
  #endif
  void set_dst_address_sv(const char* value);
  void set_dst_address_sv(const void* value, size_t size);
  ::std::string* mutable_dst_address_sv();
  ::std::string* release_dst_address_sv();
  void set_allocated_dst_address_sv(::std::string* dst_address_sv);

  // optional uint64 amount = 2;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional bool change = 1;
  bool has_change() const;
  void clear_change();
  static const int kChangeFieldNumber = 1;
  bool change() const;
  void set_change(bool value);

  // optional uint32 dst_address_tag = 3;
  bool has_dst_address_tag() const;
  void clear_dst_address_tag();
  static const int kDstAddressTagFieldNumber = 3;
  ::google::protobuf::uint32 dst_address_tag() const;
  void set_dst_address_tag(::google::protobuf::uint32 value);

  // optional uint32 change_address_index = 6;
  bool has_change_address_index() const;
  void clear_change_address_index();
  static const int kChangeAddressIndexFieldNumber = 6;
  ::google::protobuf::uint32 change_address_index() const;
  void set_change_address_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest)
 private:
  void set_has_change();
  void clear_has_change();
  void set_has_amount();
  void clear_has_amount();
  void set_has_dst_address_tag();
  void clear_has_dst_address_tag();
  void set_has_dst_address_s();
  void clear_has_dst_address_s();
  void set_has_dst_address_sv();
  void clear_has_dst_address_sv();
  void set_has_change_address_index();
  void clear_has_change_address_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dst_address_s_;
  ::google::protobuf::internal::ArenaStringPtr dst_address_sv_;
  ::google::protobuf::uint64 amount_;
  bool change_;
  ::google::protobuf::uint32 dst_address_tag_;
  ::google::protobuf::uint32 change_address_index_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinSignAddOutputResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse) */ {
 public:
  BytecoinSignAddOutputResponse();
  virtual ~BytecoinSignAddOutputResponse();

  BytecoinSignAddOutputResponse(const BytecoinSignAddOutputResponse& from);

  inline BytecoinSignAddOutputResponse& operator=(const BytecoinSignAddOutputResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinSignAddOutputResponse(BytecoinSignAddOutputResponse&& from) noexcept
    : BytecoinSignAddOutputResponse() {
    *this = ::std::move(from);
  }

  inline BytecoinSignAddOutputResponse& operator=(BytecoinSignAddOutputResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinSignAddOutputResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinSignAddOutputResponse* internal_default_instance() {
    return reinterpret_cast<const BytecoinSignAddOutputResponse*>(
               &_BytecoinSignAddOutputResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(BytecoinSignAddOutputResponse* other);
  friend void swap(BytecoinSignAddOutputResponse& a, BytecoinSignAddOutputResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinSignAddOutputResponse* New() const final {
    return CreateMaybeMessage<BytecoinSignAddOutputResponse>(NULL);
  }

  BytecoinSignAddOutputResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinSignAddOutputResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinSignAddOutputResponse& from);
  void MergeFrom(const BytecoinSignAddOutputResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinSignAddOutputResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public_key = 1;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional bytes encrypted_secret = 2;
  bool has_encrypted_secret() const;
  void clear_encrypted_secret();
  static const int kEncryptedSecretFieldNumber = 2;
  const ::std::string& encrypted_secret() const;
  void set_encrypted_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_encrypted_secret(::std::string&& value);
  #endif
  void set_encrypted_secret(const char* value);
  void set_encrypted_secret(const void* value, size_t size);
  ::std::string* mutable_encrypted_secret();
  ::std::string* release_encrypted_secret();
  void set_allocated_encrypted_secret(::std::string* encrypted_secret);

  // optional uint32 encrypted_address_type = 3;
  bool has_encrypted_address_type() const;
  void clear_encrypted_address_type();
  static const int kEncryptedAddressTypeFieldNumber = 3;
  ::google::protobuf::uint32 encrypted_address_type() const;
  void set_encrypted_address_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse)
 private:
  void set_has_public_key();
  void clear_has_public_key();
  void set_has_encrypted_secret();
  void clear_has_encrypted_secret();
  void set_has_encrypted_address_type();
  void clear_has_encrypted_address_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr encrypted_secret_;
  ::google::protobuf::uint32 encrypted_address_type_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinSignAddExtraRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinSignAddExtraRequest) */ {
 public:
  BytecoinSignAddExtraRequest();
  virtual ~BytecoinSignAddExtraRequest();

  BytecoinSignAddExtraRequest(const BytecoinSignAddExtraRequest& from);

  inline BytecoinSignAddExtraRequest& operator=(const BytecoinSignAddExtraRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinSignAddExtraRequest(BytecoinSignAddExtraRequest&& from) noexcept
    : BytecoinSignAddExtraRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinSignAddExtraRequest& operator=(BytecoinSignAddExtraRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinSignAddExtraRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinSignAddExtraRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinSignAddExtraRequest*>(
               &_BytecoinSignAddExtraRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(BytecoinSignAddExtraRequest* other);
  friend void swap(BytecoinSignAddExtraRequest& a, BytecoinSignAddExtraRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinSignAddExtraRequest* New() const final {
    return CreateMaybeMessage<BytecoinSignAddExtraRequest>(NULL);
  }

  BytecoinSignAddExtraRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinSignAddExtraRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinSignAddExtraRequest& from);
  void MergeFrom(const BytecoinSignAddExtraRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinSignAddExtraRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes extra_chunk = 1;
  bool has_extra_chunk() const;
  void clear_extra_chunk();
  static const int kExtraChunkFieldNumber = 1;
  const ::std::string& extra_chunk() const;
  void set_extra_chunk(const ::std::string& value);
  #if LANG_CXX11
  void set_extra_chunk(::std::string&& value);
  #endif
  void set_extra_chunk(const char* value);
  void set_extra_chunk(const void* value, size_t size);
  ::std::string* mutable_extra_chunk();
  ::std::string* release_extra_chunk();
  void set_allocated_extra_chunk(::std::string* extra_chunk);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinSignAddExtraRequest)
 private:
  void set_has_extra_chunk();
  void clear_has_extra_chunk();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr extra_chunk_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinSignStepARequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinSignStepARequest) */ {
 public:
  BytecoinSignStepARequest();
  virtual ~BytecoinSignStepARequest();

  BytecoinSignStepARequest(const BytecoinSignStepARequest& from);

  inline BytecoinSignStepARequest& operator=(const BytecoinSignStepARequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinSignStepARequest(BytecoinSignStepARequest&& from) noexcept
    : BytecoinSignStepARequest() {
    *this = ::std::move(from);
  }

  inline BytecoinSignStepARequest& operator=(BytecoinSignStepARequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinSignStepARequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinSignStepARequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinSignStepARequest*>(
               &_BytecoinSignStepARequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(BytecoinSignStepARequest* other);
  friend void swap(BytecoinSignStepARequest& a, BytecoinSignStepARequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinSignStepARequest* New() const final {
    return CreateMaybeMessage<BytecoinSignStepARequest>(NULL);
  }

  BytecoinSignStepARequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinSignStepARequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinSignStepARequest& from);
  void MergeFrom(const BytecoinSignStepARequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinSignStepARequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes inv_output_main_hash = 1;
  bool has_inv_output_main_hash() const;
  void clear_inv_output_main_hash();
  static const int kInvOutputMainHashFieldNumber = 1;
  const ::std::string& inv_output_main_hash() const;
  void set_inv_output_main_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_inv_output_main_hash(::std::string&& value);
  #endif
  void set_inv_output_main_hash(const char* value);
  void set_inv_output_main_hash(const void* value, size_t size);
  ::std::string* mutable_inv_output_main_hash();
  ::std::string* release_inv_output_main_hash();
  void set_allocated_inv_output_main_hash(::std::string* inv_output_main_hash);

  // optional uint64 address_index = 2;
  bool has_address_index() const;
  void clear_address_index();
  static const int kAddressIndexFieldNumber = 2;
  ::google::protobuf::uint64 address_index() const;
  void set_address_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinSignStepARequest)
 private:
  void set_has_inv_output_main_hash();
  void clear_has_inv_output_main_hash();
  void set_has_address_index();
  void clear_has_address_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr inv_output_main_hash_;
  ::google::protobuf::uint64 address_index_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinSignStepAResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse) */ {
 public:
  BytecoinSignStepAResponse();
  virtual ~BytecoinSignStepAResponse();

  BytecoinSignStepAResponse(const BytecoinSignStepAResponse& from);

  inline BytecoinSignStepAResponse& operator=(const BytecoinSignStepAResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinSignStepAResponse(BytecoinSignStepAResponse&& from) noexcept
    : BytecoinSignStepAResponse() {
    *this = ::std::move(from);
  }

  inline BytecoinSignStepAResponse& operator=(BytecoinSignStepAResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinSignStepAResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinSignStepAResponse* internal_default_instance() {
    return reinterpret_cast<const BytecoinSignStepAResponse*>(
               &_BytecoinSignStepAResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(BytecoinSignStepAResponse* other);
  friend void swap(BytecoinSignStepAResponse& a, BytecoinSignStepAResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinSignStepAResponse* New() const final {
    return CreateMaybeMessage<BytecoinSignStepAResponse>(NULL);
  }

  BytecoinSignStepAResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinSignStepAResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinSignStepAResponse& from);
  void MergeFrom(const BytecoinSignStepAResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinSignStepAResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sig_p = 1;
  bool has_sig_p() const;
  void clear_sig_p();
  static const int kSigPFieldNumber = 1;
  const ::std::string& sig_p() const;
  void set_sig_p(const ::std::string& value);
  #if LANG_CXX11
  void set_sig_p(::std::string&& value);
  #endif
  void set_sig_p(const char* value);
  void set_sig_p(const void* value, size_t size);
  ::std::string* mutable_sig_p();
  ::std::string* release_sig_p();
  void set_allocated_sig_p(::std::string* sig_p);

  // optional bytes x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  const ::std::string& x() const;
  void set_x(const ::std::string& value);
  #if LANG_CXX11
  void set_x(::std::string&& value);
  #endif
  void set_x(const char* value);
  void set_x(const void* value, size_t size);
  ::std::string* mutable_x();
  ::std::string* release_x();
  void set_allocated_x(::std::string* x);

  // optional bytes y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  const ::std::string& y() const;
  void set_y(const ::std::string& value);
  #if LANG_CXX11
  void set_y(::std::string&& value);
  #endif
  void set_y(const char* value);
  void set_y(const void* value, size_t size);
  ::std::string* mutable_y();
  ::std::string* release_y();
  void set_allocated_y(::std::string* y);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse)
 private:
  void set_has_sig_p();
  void clear_has_sig_p();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sig_p_;
  ::google::protobuf::internal::ArenaStringPtr x_;
  ::google::protobuf::internal::ArenaStringPtr y_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinSignStepAMoreDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinSignStepAMoreDataRequest) */ {
 public:
  BytecoinSignStepAMoreDataRequest();
  virtual ~BytecoinSignStepAMoreDataRequest();

  BytecoinSignStepAMoreDataRequest(const BytecoinSignStepAMoreDataRequest& from);

  inline BytecoinSignStepAMoreDataRequest& operator=(const BytecoinSignStepAMoreDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinSignStepAMoreDataRequest(BytecoinSignStepAMoreDataRequest&& from) noexcept
    : BytecoinSignStepAMoreDataRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinSignStepAMoreDataRequest& operator=(BytecoinSignStepAMoreDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinSignStepAMoreDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinSignStepAMoreDataRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinSignStepAMoreDataRequest*>(
               &_BytecoinSignStepAMoreDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(BytecoinSignStepAMoreDataRequest* other);
  friend void swap(BytecoinSignStepAMoreDataRequest& a, BytecoinSignStepAMoreDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinSignStepAMoreDataRequest* New() const final {
    return CreateMaybeMessage<BytecoinSignStepAMoreDataRequest>(NULL);
  }

  BytecoinSignStepAMoreDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinSignStepAMoreDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinSignStepAMoreDataRequest& from);
  void MergeFrom(const BytecoinSignStepAMoreDataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinSignStepAMoreDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data_chunk = 1;
  bool has_data_chunk() const;
  void clear_data_chunk();
  static const int kDataChunkFieldNumber = 1;
  const ::std::string& data_chunk() const;
  void set_data_chunk(const ::std::string& value);
  #if LANG_CXX11
  void set_data_chunk(::std::string&& value);
  #endif
  void set_data_chunk(const char* value);
  void set_data_chunk(const void* value, size_t size);
  ::std::string* mutable_data_chunk();
  ::std::string* release_data_chunk();
  void set_allocated_data_chunk(::std::string* data_chunk);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinSignStepAMoreDataRequest)
 private:
  void set_has_data_chunk();
  void clear_has_data_chunk();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_chunk_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinSignGetC0Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinSignGetC0Request) */ {
 public:
  BytecoinSignGetC0Request();
  virtual ~BytecoinSignGetC0Request();

  BytecoinSignGetC0Request(const BytecoinSignGetC0Request& from);

  inline BytecoinSignGetC0Request& operator=(const BytecoinSignGetC0Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinSignGetC0Request(BytecoinSignGetC0Request&& from) noexcept
    : BytecoinSignGetC0Request() {
    *this = ::std::move(from);
  }

  inline BytecoinSignGetC0Request& operator=(BytecoinSignGetC0Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinSignGetC0Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinSignGetC0Request* internal_default_instance() {
    return reinterpret_cast<const BytecoinSignGetC0Request*>(
               &_BytecoinSignGetC0Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(BytecoinSignGetC0Request* other);
  friend void swap(BytecoinSignGetC0Request& a, BytecoinSignGetC0Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinSignGetC0Request* New() const final {
    return CreateMaybeMessage<BytecoinSignGetC0Request>(NULL);
  }

  BytecoinSignGetC0Request* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinSignGetC0Request>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinSignGetC0Request& from);
  void MergeFrom(const BytecoinSignGetC0Request& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinSignGetC0Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinSignGetC0Request)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinSignGetC0Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinSignGetC0Response) */ {
 public:
  BytecoinSignGetC0Response();
  virtual ~BytecoinSignGetC0Response();

  BytecoinSignGetC0Response(const BytecoinSignGetC0Response& from);

  inline BytecoinSignGetC0Response& operator=(const BytecoinSignGetC0Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinSignGetC0Response(BytecoinSignGetC0Response&& from) noexcept
    : BytecoinSignGetC0Response() {
    *this = ::std::move(from);
  }

  inline BytecoinSignGetC0Response& operator=(BytecoinSignGetC0Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinSignGetC0Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinSignGetC0Response* internal_default_instance() {
    return reinterpret_cast<const BytecoinSignGetC0Response*>(
               &_BytecoinSignGetC0Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(BytecoinSignGetC0Response* other);
  friend void swap(BytecoinSignGetC0Response& a, BytecoinSignGetC0Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinSignGetC0Response* New() const final {
    return CreateMaybeMessage<BytecoinSignGetC0Response>(NULL);
  }

  BytecoinSignGetC0Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinSignGetC0Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinSignGetC0Response& from);
  void MergeFrom(const BytecoinSignGetC0Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinSignGetC0Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes c0 = 1;
  bool has_c0() const;
  void clear_c0();
  static const int kC0FieldNumber = 1;
  const ::std::string& c0() const;
  void set_c0(const ::std::string& value);
  #if LANG_CXX11
  void set_c0(::std::string&& value);
  #endif
  void set_c0(const char* value);
  void set_c0(const void* value, size_t size);
  ::std::string* mutable_c0();
  ::std::string* release_c0();
  void set_allocated_c0(::std::string* c0);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinSignGetC0Response)
 private:
  void set_has_c0();
  void clear_has_c0();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr c0_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinSignStepBRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest) */ {
 public:
  BytecoinSignStepBRequest();
  virtual ~BytecoinSignStepBRequest();

  BytecoinSignStepBRequest(const BytecoinSignStepBRequest& from);

  inline BytecoinSignStepBRequest& operator=(const BytecoinSignStepBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinSignStepBRequest(BytecoinSignStepBRequest&& from) noexcept
    : BytecoinSignStepBRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinSignStepBRequest& operator=(BytecoinSignStepBRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinSignStepBRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinSignStepBRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinSignStepBRequest*>(
               &_BytecoinSignStepBRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(BytecoinSignStepBRequest* other);
  friend void swap(BytecoinSignStepBRequest& a, BytecoinSignStepBRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinSignStepBRequest* New() const final {
    return CreateMaybeMessage<BytecoinSignStepBRequest>(NULL);
  }

  BytecoinSignStepBRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinSignStepBRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinSignStepBRequest& from);
  void MergeFrom(const BytecoinSignStepBRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinSignStepBRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes inv_output_main_hash = 1;
  bool has_inv_output_main_hash() const;
  void clear_inv_output_main_hash();
  static const int kInvOutputMainHashFieldNumber = 1;
  const ::std::string& inv_output_main_hash() const;
  void set_inv_output_main_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_inv_output_main_hash(::std::string&& value);
  #endif
  void set_inv_output_main_hash(const char* value);
  void set_inv_output_main_hash(const void* value, size_t size);
  ::std::string* mutable_inv_output_main_hash();
  ::std::string* release_inv_output_main_hash();
  void set_allocated_inv_output_main_hash(::std::string* inv_output_main_hash);

  // optional bytes my_c = 3;
  bool has_my_c() const;
  void clear_my_c();
  static const int kMyCFieldNumber = 3;
  const ::std::string& my_c() const;
  void set_my_c(const ::std::string& value);
  #if LANG_CXX11
  void set_my_c(::std::string&& value);
  #endif
  void set_my_c(const char* value);
  void set_my_c(const void* value, size_t size);
  ::std::string* mutable_my_c();
  ::std::string* release_my_c();
  void set_allocated_my_c(::std::string* my_c);

  // optional uint64 address_index = 2;
  bool has_address_index() const;
  void clear_address_index();
  static const int kAddressIndexFieldNumber = 2;
  ::google::protobuf::uint64 address_index() const;
  void set_address_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest)
 private:
  void set_has_inv_output_main_hash();
  void clear_has_inv_output_main_hash();
  void set_has_address_index();
  void clear_has_address_index();
  void set_has_my_c();
  void clear_has_my_c();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr inv_output_main_hash_;
  ::google::protobuf::internal::ArenaStringPtr my_c_;
  ::google::protobuf::uint64 address_index_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinSignStepBResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse) */ {
 public:
  BytecoinSignStepBResponse();
  virtual ~BytecoinSignStepBResponse();

  BytecoinSignStepBResponse(const BytecoinSignStepBResponse& from);

  inline BytecoinSignStepBResponse& operator=(const BytecoinSignStepBResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinSignStepBResponse(BytecoinSignStepBResponse&& from) noexcept
    : BytecoinSignStepBResponse() {
    *this = ::std::move(from);
  }

  inline BytecoinSignStepBResponse& operator=(BytecoinSignStepBResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinSignStepBResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinSignStepBResponse* internal_default_instance() {
    return reinterpret_cast<const BytecoinSignStepBResponse*>(
               &_BytecoinSignStepBResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(BytecoinSignStepBResponse* other);
  friend void swap(BytecoinSignStepBResponse& a, BytecoinSignStepBResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinSignStepBResponse* New() const final {
    return CreateMaybeMessage<BytecoinSignStepBResponse>(NULL);
  }

  BytecoinSignStepBResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinSignStepBResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinSignStepBResponse& from);
  void MergeFrom(const BytecoinSignStepBResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinSignStepBResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes my_ra = 1;
  bool has_my_ra() const;
  void clear_my_ra();
  static const int kMyRaFieldNumber = 1;
  const ::std::string& my_ra() const;
  void set_my_ra(const ::std::string& value);
  #if LANG_CXX11
  void set_my_ra(::std::string&& value);
  #endif
  void set_my_ra(const char* value);
  void set_my_ra(const void* value, size_t size);
  ::std::string* mutable_my_ra();
  ::std::string* release_my_ra();
  void set_allocated_my_ra(::std::string* my_ra);

  // optional bytes rb = 2;
  bool has_rb() const;
  void clear_rb();
  static const int kRbFieldNumber = 2;
  const ::std::string& rb() const;
  void set_rb(const ::std::string& value);
  #if LANG_CXX11
  void set_rb(::std::string&& value);
  #endif
  void set_rb(const char* value);
  void set_rb(const void* value, size_t size);
  ::std::string* mutable_rb();
  ::std::string* release_rb();
  void set_allocated_rb(::std::string* rb);

  // optional bytes rc = 3;
  bool has_rc() const;
  void clear_rc();
  static const int kRcFieldNumber = 3;
  const ::std::string& rc() const;
  void set_rc(const ::std::string& value);
  #if LANG_CXX11
  void set_rc(::std::string&& value);
  #endif
  void set_rc(const char* value);
  void set_rc(const void* value, size_t size);
  ::std::string* mutable_rc();
  ::std::string* release_rc();
  void set_allocated_rc(::std::string* rc);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse)
 private:
  void set_has_my_ra();
  void clear_has_my_ra();
  void set_has_rb();
  void clear_has_rb();
  void set_has_rc();
  void clear_has_rc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr my_ra_;
  ::google::protobuf::internal::ArenaStringPtr rb_;
  ::google::protobuf::internal::ArenaStringPtr rc_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinStartProofRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinStartProofRequest) */ {
 public:
  BytecoinStartProofRequest();
  virtual ~BytecoinStartProofRequest();

  BytecoinStartProofRequest(const BytecoinStartProofRequest& from);

  inline BytecoinStartProofRequest& operator=(const BytecoinStartProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinStartProofRequest(BytecoinStartProofRequest&& from) noexcept
    : BytecoinStartProofRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinStartProofRequest& operator=(BytecoinStartProofRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinStartProofRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinStartProofRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinStartProofRequest*>(
               &_BytecoinStartProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(BytecoinStartProofRequest* other);
  friend void swap(BytecoinStartProofRequest& a, BytecoinStartProofRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinStartProofRequest* New() const final {
    return CreateMaybeMessage<BytecoinStartProofRequest>(NULL);
  }

  BytecoinStartProofRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinStartProofRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinStartProofRequest& from);
  void MergeFrom(const BytecoinStartProofRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinStartProofRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 data_size = 1;
  bool has_data_size() const;
  void clear_data_size();
  static const int kDataSizeFieldNumber = 1;
  ::google::protobuf::uint32 data_size() const;
  void set_data_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinStartProofRequest)
 private:
  void set_has_data_size();
  void clear_has_data_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 data_size_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BytecoinProofMoreDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hw.trezor.messages.bytecoin.BytecoinProofMoreDataRequest) */ {
 public:
  BytecoinProofMoreDataRequest();
  virtual ~BytecoinProofMoreDataRequest();

  BytecoinProofMoreDataRequest(const BytecoinProofMoreDataRequest& from);

  inline BytecoinProofMoreDataRequest& operator=(const BytecoinProofMoreDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BytecoinProofMoreDataRequest(BytecoinProofMoreDataRequest&& from) noexcept
    : BytecoinProofMoreDataRequest() {
    *this = ::std::move(from);
  }

  inline BytecoinProofMoreDataRequest& operator=(BytecoinProofMoreDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BytecoinProofMoreDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytecoinProofMoreDataRequest* internal_default_instance() {
    return reinterpret_cast<const BytecoinProofMoreDataRequest*>(
               &_BytecoinProofMoreDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(BytecoinProofMoreDataRequest* other);
  friend void swap(BytecoinProofMoreDataRequest& a, BytecoinProofMoreDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BytecoinProofMoreDataRequest* New() const final {
    return CreateMaybeMessage<BytecoinProofMoreDataRequest>(NULL);
  }

  BytecoinProofMoreDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BytecoinProofMoreDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BytecoinProofMoreDataRequest& from);
  void MergeFrom(const BytecoinProofMoreDataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytecoinProofMoreDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data_chunk = 1;
  bool has_data_chunk() const;
  void clear_data_chunk();
  static const int kDataChunkFieldNumber = 1;
  const ::std::string& data_chunk() const;
  void set_data_chunk(const ::std::string& value);
  #if LANG_CXX11
  void set_data_chunk(::std::string&& value);
  #endif
  void set_data_chunk(const char* value);
  void set_data_chunk(const void* value, size_t size);
  ::std::string* mutable_data_chunk();
  ::std::string* release_data_chunk();
  void set_allocated_data_chunk(::std::string* data_chunk);

  // @@protoc_insertion_point(class_scope:hw.trezor.messages.bytecoin.BytecoinProofMoreDataRequest)
 private:
  void set_has_data_chunk();
  void clear_has_data_chunk();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_chunk_;
  friend struct ::protobuf_messages_2dbytecoin_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BytecoinStartRequest

// optional bytes debug_request = 1;
inline bool BytecoinStartRequest::has_debug_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinStartRequest::set_has_debug_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinStartRequest::clear_has_debug_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinStartRequest::clear_debug_request() {
  debug_request_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_debug_request();
}
inline const ::std::string& BytecoinStartRequest::debug_request() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinStartRequest.debug_request)
  return debug_request_.GetNoArena();
}
inline void BytecoinStartRequest::set_debug_request(const ::std::string& value) {
  set_has_debug_request();
  debug_request_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinStartRequest.debug_request)
}
#if LANG_CXX11
inline void BytecoinStartRequest::set_debug_request(::std::string&& value) {
  set_has_debug_request();
  debug_request_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinStartRequest.debug_request)
}
#endif
inline void BytecoinStartRequest::set_debug_request(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_debug_request();
  debug_request_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinStartRequest.debug_request)
}
inline void BytecoinStartRequest::set_debug_request(const void* value, size_t size) {
  set_has_debug_request();
  debug_request_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinStartRequest.debug_request)
}
inline ::std::string* BytecoinStartRequest::mutable_debug_request() {
  set_has_debug_request();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinStartRequest.debug_request)
  return debug_request_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinStartRequest::release_debug_request() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinStartRequest.debug_request)
  if (!has_debug_request()) {
    return NULL;
  }
  clear_has_debug_request();
  return debug_request_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinStartRequest::set_allocated_debug_request(::std::string* debug_request) {
  if (debug_request != NULL) {
    set_has_debug_request();
  } else {
    clear_has_debug_request();
  }
  debug_request_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), debug_request);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinStartRequest.debug_request)
}

// -------------------------------------------------------------------

// BytecoinStartResponse

// optional bytes wallet_key = 1;
inline bool BytecoinStartResponse::has_wallet_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinStartResponse::set_has_wallet_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinStartResponse::clear_has_wallet_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinStartResponse::clear_wallet_key() {
  wallet_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_wallet_key();
}
inline const ::std::string& BytecoinStartResponse::wallet_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinStartResponse.wallet_key)
  return wallet_key_.GetNoArena();
}
inline void BytecoinStartResponse::set_wallet_key(const ::std::string& value) {
  set_has_wallet_key();
  wallet_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinStartResponse.wallet_key)
}
#if LANG_CXX11
inline void BytecoinStartResponse::set_wallet_key(::std::string&& value) {
  set_has_wallet_key();
  wallet_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinStartResponse.wallet_key)
}
#endif
inline void BytecoinStartResponse::set_wallet_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_wallet_key();
  wallet_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinStartResponse.wallet_key)
}
inline void BytecoinStartResponse::set_wallet_key(const void* value, size_t size) {
  set_has_wallet_key();
  wallet_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinStartResponse.wallet_key)
}
inline ::std::string* BytecoinStartResponse::mutable_wallet_key() {
  set_has_wallet_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinStartResponse.wallet_key)
  return wallet_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinStartResponse::release_wallet_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinStartResponse.wallet_key)
  if (!has_wallet_key()) {
    return NULL;
  }
  clear_has_wallet_key();
  return wallet_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinStartResponse::set_allocated_wallet_key(::std::string* wallet_key) {
  if (wallet_key != NULL) {
    set_has_wallet_key();
  } else {
    clear_has_wallet_key();
  }
  wallet_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wallet_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinStartResponse.wallet_key)
}

// optional bytes A_plus_sH = 2;
inline bool BytecoinStartResponse::has_a_plus_sh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytecoinStartResponse::set_has_a_plus_sh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytecoinStartResponse::clear_has_a_plus_sh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytecoinStartResponse::clear_a_plus_sh() {
  a_plus_sh_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_a_plus_sh();
}
inline const ::std::string& BytecoinStartResponse::a_plus_sh() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinStartResponse.A_plus_sH)
  return a_plus_sh_.GetNoArena();
}
inline void BytecoinStartResponse::set_a_plus_sh(const ::std::string& value) {
  set_has_a_plus_sh();
  a_plus_sh_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinStartResponse.A_plus_sH)
}
#if LANG_CXX11
inline void BytecoinStartResponse::set_a_plus_sh(::std::string&& value) {
  set_has_a_plus_sh();
  a_plus_sh_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinStartResponse.A_plus_sH)
}
#endif
inline void BytecoinStartResponse::set_a_plus_sh(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_a_plus_sh();
  a_plus_sh_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinStartResponse.A_plus_sH)
}
inline void BytecoinStartResponse::set_a_plus_sh(const void* value, size_t size) {
  set_has_a_plus_sh();
  a_plus_sh_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinStartResponse.A_plus_sH)
}
inline ::std::string* BytecoinStartResponse::mutable_a_plus_sh() {
  set_has_a_plus_sh();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinStartResponse.A_plus_sH)
  return a_plus_sh_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinStartResponse::release_a_plus_sh() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinStartResponse.A_plus_sH)
  if (!has_a_plus_sh()) {
    return NULL;
  }
  clear_has_a_plus_sh();
  return a_plus_sh_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinStartResponse::set_allocated_a_plus_sh(::std::string* a_plus_sh) {
  if (a_plus_sh != NULL) {
    set_has_a_plus_sh();
  } else {
    clear_has_a_plus_sh();
  }
  a_plus_sh_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), a_plus_sh);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinStartResponse.A_plus_sH)
}

// optional bytes v_mul_A_plus_sH = 3;
inline bool BytecoinStartResponse::has_v_mul_a_plus_sh() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BytecoinStartResponse::set_has_v_mul_a_plus_sh() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BytecoinStartResponse::clear_has_v_mul_a_plus_sh() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BytecoinStartResponse::clear_v_mul_a_plus_sh() {
  v_mul_a_plus_sh_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_v_mul_a_plus_sh();
}
inline const ::std::string& BytecoinStartResponse::v_mul_a_plus_sh() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinStartResponse.v_mul_A_plus_sH)
  return v_mul_a_plus_sh_.GetNoArena();
}
inline void BytecoinStartResponse::set_v_mul_a_plus_sh(const ::std::string& value) {
  set_has_v_mul_a_plus_sh();
  v_mul_a_plus_sh_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinStartResponse.v_mul_A_plus_sH)
}
#if LANG_CXX11
inline void BytecoinStartResponse::set_v_mul_a_plus_sh(::std::string&& value) {
  set_has_v_mul_a_plus_sh();
  v_mul_a_plus_sh_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinStartResponse.v_mul_A_plus_sH)
}
#endif
inline void BytecoinStartResponse::set_v_mul_a_plus_sh(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_v_mul_a_plus_sh();
  v_mul_a_plus_sh_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinStartResponse.v_mul_A_plus_sH)
}
inline void BytecoinStartResponse::set_v_mul_a_plus_sh(const void* value, size_t size) {
  set_has_v_mul_a_plus_sh();
  v_mul_a_plus_sh_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinStartResponse.v_mul_A_plus_sH)
}
inline ::std::string* BytecoinStartResponse::mutable_v_mul_a_plus_sh() {
  set_has_v_mul_a_plus_sh();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinStartResponse.v_mul_A_plus_sH)
  return v_mul_a_plus_sh_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinStartResponse::release_v_mul_a_plus_sh() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinStartResponse.v_mul_A_plus_sH)
  if (!has_v_mul_a_plus_sh()) {
    return NULL;
  }
  clear_has_v_mul_a_plus_sh();
  return v_mul_a_plus_sh_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinStartResponse::set_allocated_v_mul_a_plus_sh(::std::string* v_mul_a_plus_sh) {
  if (v_mul_a_plus_sh != NULL) {
    set_has_v_mul_a_plus_sh();
  } else {
    clear_has_v_mul_a_plus_sh();
  }
  v_mul_a_plus_sh_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), v_mul_a_plus_sh);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinStartResponse.v_mul_A_plus_sH)
}

// optional bytes view_public_key = 4;
inline bool BytecoinStartResponse::has_view_public_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BytecoinStartResponse::set_has_view_public_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BytecoinStartResponse::clear_has_view_public_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BytecoinStartResponse::clear_view_public_key() {
  view_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_view_public_key();
}
inline const ::std::string& BytecoinStartResponse::view_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinStartResponse.view_public_key)
  return view_public_key_.GetNoArena();
}
inline void BytecoinStartResponse::set_view_public_key(const ::std::string& value) {
  set_has_view_public_key();
  view_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinStartResponse.view_public_key)
}
#if LANG_CXX11
inline void BytecoinStartResponse::set_view_public_key(::std::string&& value) {
  set_has_view_public_key();
  view_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinStartResponse.view_public_key)
}
#endif
inline void BytecoinStartResponse::set_view_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_view_public_key();
  view_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinStartResponse.view_public_key)
}
inline void BytecoinStartResponse::set_view_public_key(const void* value, size_t size) {
  set_has_view_public_key();
  view_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinStartResponse.view_public_key)
}
inline ::std::string* BytecoinStartResponse::mutable_view_public_key() {
  set_has_view_public_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinStartResponse.view_public_key)
  return view_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinStartResponse::release_view_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinStartResponse.view_public_key)
  if (!has_view_public_key()) {
    return NULL;
  }
  clear_has_view_public_key();
  return view_public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinStartResponse::set_allocated_view_public_key(::std::string* view_public_key) {
  if (view_public_key != NULL) {
    set_has_view_public_key();
  } else {
    clear_has_view_public_key();
  }
  view_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), view_public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinStartResponse.view_public_key)
}

// optional bytes debug_response = 5;
inline bool BytecoinStartResponse::has_debug_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BytecoinStartResponse::set_has_debug_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BytecoinStartResponse::clear_has_debug_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BytecoinStartResponse::clear_debug_response() {
  debug_response_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_debug_response();
}
inline const ::std::string& BytecoinStartResponse::debug_response() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinStartResponse.debug_response)
  return debug_response_.GetNoArena();
}
inline void BytecoinStartResponse::set_debug_response(const ::std::string& value) {
  set_has_debug_response();
  debug_response_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinStartResponse.debug_response)
}
#if LANG_CXX11
inline void BytecoinStartResponse::set_debug_response(::std::string&& value) {
  set_has_debug_response();
  debug_response_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinStartResponse.debug_response)
}
#endif
inline void BytecoinStartResponse::set_debug_response(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_debug_response();
  debug_response_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinStartResponse.debug_response)
}
inline void BytecoinStartResponse::set_debug_response(const void* value, size_t size) {
  set_has_debug_response();
  debug_response_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinStartResponse.debug_response)
}
inline ::std::string* BytecoinStartResponse::mutable_debug_response() {
  set_has_debug_response();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinStartResponse.debug_response)
  return debug_response_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinStartResponse::release_debug_response() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinStartResponse.debug_response)
  if (!has_debug_response()) {
    return NULL;
  }
  clear_has_debug_response();
  return debug_response_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinStartResponse::set_allocated_debug_response(::std::string* debug_response) {
  if (debug_response != NULL) {
    set_has_debug_response();
  } else {
    clear_has_debug_response();
  }
  debug_response_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), debug_response);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinStartResponse.debug_response)
}

// -------------------------------------------------------------------

// BytecoinScanOutputsRequest

// repeated bytes output_public_key = 1;
inline int BytecoinScanOutputsRequest::output_public_key_size() const {
  return output_public_key_.size();
}
inline void BytecoinScanOutputsRequest::clear_output_public_key() {
  output_public_key_.Clear();
}
inline const ::std::string& BytecoinScanOutputsRequest::output_public_key(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
  return output_public_key_.Get(index);
}
inline ::std::string* BytecoinScanOutputsRequest::mutable_output_public_key(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
  return output_public_key_.Mutable(index);
}
inline void BytecoinScanOutputsRequest::set_output_public_key(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
  output_public_key_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BytecoinScanOutputsRequest::set_output_public_key(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
  output_public_key_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BytecoinScanOutputsRequest::set_output_public_key(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  output_public_key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
}
inline void BytecoinScanOutputsRequest::set_output_public_key(int index, const void* value, size_t size) {
  output_public_key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
}
inline ::std::string* BytecoinScanOutputsRequest::add_output_public_key() {
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
  return output_public_key_.Add();
}
inline void BytecoinScanOutputsRequest::add_output_public_key(const ::std::string& value) {
  output_public_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
}
#if LANG_CXX11
inline void BytecoinScanOutputsRequest::add_output_public_key(::std::string&& value) {
  output_public_key_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
}
#endif
inline void BytecoinScanOutputsRequest::add_output_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  output_public_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
}
inline void BytecoinScanOutputsRequest::add_output_public_key(const void* value, size_t size) {
  output_public_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BytecoinScanOutputsRequest::output_public_key() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
  return output_public_key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BytecoinScanOutputsRequest::mutable_output_public_key() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bytecoin.BytecoinScanOutputsRequest.output_public_key)
  return &output_public_key_;
}

// -------------------------------------------------------------------

// BytecoinScanOutputsResponse

// repeated bytes Pv = 1;
inline int BytecoinScanOutputsResponse::pv_size() const {
  return pv_.size();
}
inline void BytecoinScanOutputsResponse::clear_pv() {
  pv_.Clear();
}
inline const ::std::string& BytecoinScanOutputsResponse::pv(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
  return pv_.Get(index);
}
inline ::std::string* BytecoinScanOutputsResponse::mutable_pv(int index) {
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
  return pv_.Mutable(index);
}
inline void BytecoinScanOutputsResponse::set_pv(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
  pv_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BytecoinScanOutputsResponse::set_pv(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
  pv_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BytecoinScanOutputsResponse::set_pv(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  pv_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
}
inline void BytecoinScanOutputsResponse::set_pv(int index, const void* value, size_t size) {
  pv_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
}
inline ::std::string* BytecoinScanOutputsResponse::add_pv() {
  // @@protoc_insertion_point(field_add_mutable:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
  return pv_.Add();
}
inline void BytecoinScanOutputsResponse::add_pv(const ::std::string& value) {
  pv_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
}
#if LANG_CXX11
inline void BytecoinScanOutputsResponse::add_pv(::std::string&& value) {
  pv_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
}
#endif
inline void BytecoinScanOutputsResponse::add_pv(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  pv_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
}
inline void BytecoinScanOutputsResponse::add_pv(const void* value, size_t size) {
  pv_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BytecoinScanOutputsResponse::pv() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
  return pv_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BytecoinScanOutputsResponse::mutable_pv() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bytecoin.BytecoinScanOutputsResponse.Pv)
  return &pv_;
}

// -------------------------------------------------------------------

// BytecoinGenerateKeyimageRequest

// optional bytes output_public_key = 1;
inline bool BytecoinGenerateKeyimageRequest::has_output_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinGenerateKeyimageRequest::set_has_output_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinGenerateKeyimageRequest::clear_has_output_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinGenerateKeyimageRequest::clear_output_public_key() {
  output_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_output_public_key();
}
inline const ::std::string& BytecoinGenerateKeyimageRequest::output_public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.output_public_key)
  return output_public_key_.GetNoArena();
}
inline void BytecoinGenerateKeyimageRequest::set_output_public_key(const ::std::string& value) {
  set_has_output_public_key();
  output_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.output_public_key)
}
#if LANG_CXX11
inline void BytecoinGenerateKeyimageRequest::set_output_public_key(::std::string&& value) {
  set_has_output_public_key();
  output_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.output_public_key)
}
#endif
inline void BytecoinGenerateKeyimageRequest::set_output_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_output_public_key();
  output_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.output_public_key)
}
inline void BytecoinGenerateKeyimageRequest::set_output_public_key(const void* value, size_t size) {
  set_has_output_public_key();
  output_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.output_public_key)
}
inline ::std::string* BytecoinGenerateKeyimageRequest::mutable_output_public_key() {
  set_has_output_public_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.output_public_key)
  return output_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinGenerateKeyimageRequest::release_output_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.output_public_key)
  if (!has_output_public_key()) {
    return NULL;
  }
  clear_has_output_public_key();
  return output_public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinGenerateKeyimageRequest::set_allocated_output_public_key(::std::string* output_public_key) {
  if (output_public_key != NULL) {
    set_has_output_public_key();
  } else {
    clear_has_output_public_key();
  }
  output_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.output_public_key)
}

// optional bytes inv_output_main_hash = 2;
inline bool BytecoinGenerateKeyimageRequest::has_inv_output_main_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytecoinGenerateKeyimageRequest::set_has_inv_output_main_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytecoinGenerateKeyimageRequest::clear_has_inv_output_main_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytecoinGenerateKeyimageRequest::clear_inv_output_main_hash() {
  inv_output_main_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_inv_output_main_hash();
}
inline const ::std::string& BytecoinGenerateKeyimageRequest::inv_output_main_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.inv_output_main_hash)
  return inv_output_main_hash_.GetNoArena();
}
inline void BytecoinGenerateKeyimageRequest::set_inv_output_main_hash(const ::std::string& value) {
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.inv_output_main_hash)
}
#if LANG_CXX11
inline void BytecoinGenerateKeyimageRequest::set_inv_output_main_hash(::std::string&& value) {
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.inv_output_main_hash)
}
#endif
inline void BytecoinGenerateKeyimageRequest::set_inv_output_main_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.inv_output_main_hash)
}
inline void BytecoinGenerateKeyimageRequest::set_inv_output_main_hash(const void* value, size_t size) {
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.inv_output_main_hash)
}
inline ::std::string* BytecoinGenerateKeyimageRequest::mutable_inv_output_main_hash() {
  set_has_inv_output_main_hash();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.inv_output_main_hash)
  return inv_output_main_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinGenerateKeyimageRequest::release_inv_output_main_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.inv_output_main_hash)
  if (!has_inv_output_main_hash()) {
    return NULL;
  }
  clear_has_inv_output_main_hash();
  return inv_output_main_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinGenerateKeyimageRequest::set_allocated_inv_output_main_hash(::std::string* inv_output_main_hash) {
  if (inv_output_main_hash != NULL) {
    set_has_inv_output_main_hash();
  } else {
    clear_has_inv_output_main_hash();
  }
  inv_output_main_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), inv_output_main_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.inv_output_main_hash)
}

// optional uint32 address_index = 3;
inline bool BytecoinGenerateKeyimageRequest::has_address_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BytecoinGenerateKeyimageRequest::set_has_address_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BytecoinGenerateKeyimageRequest::clear_has_address_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BytecoinGenerateKeyimageRequest::clear_address_index() {
  address_index_ = 0u;
  clear_has_address_index();
}
inline ::google::protobuf::uint32 BytecoinGenerateKeyimageRequest::address_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.address_index)
  return address_index_;
}
inline void BytecoinGenerateKeyimageRequest::set_address_index(::google::protobuf::uint32 value) {
  set_has_address_index();
  address_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageRequest.address_index)
}

// -------------------------------------------------------------------

// BytecoinGenerateKeyimageResponse

// optional bytes keyimage = 1;
inline bool BytecoinGenerateKeyimageResponse::has_keyimage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinGenerateKeyimageResponse::set_has_keyimage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinGenerateKeyimageResponse::clear_has_keyimage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinGenerateKeyimageResponse::clear_keyimage() {
  keyimage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keyimage();
}
inline const ::std::string& BytecoinGenerateKeyimageResponse::keyimage() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageResponse.keyimage)
  return keyimage_.GetNoArena();
}
inline void BytecoinGenerateKeyimageResponse::set_keyimage(const ::std::string& value) {
  set_has_keyimage();
  keyimage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageResponse.keyimage)
}
#if LANG_CXX11
inline void BytecoinGenerateKeyimageResponse::set_keyimage(::std::string&& value) {
  set_has_keyimage();
  keyimage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageResponse.keyimage)
}
#endif
inline void BytecoinGenerateKeyimageResponse::set_keyimage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keyimage();
  keyimage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageResponse.keyimage)
}
inline void BytecoinGenerateKeyimageResponse::set_keyimage(const void* value, size_t size) {
  set_has_keyimage();
  keyimage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageResponse.keyimage)
}
inline ::std::string* BytecoinGenerateKeyimageResponse::mutable_keyimage() {
  set_has_keyimage();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageResponse.keyimage)
  return keyimage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinGenerateKeyimageResponse::release_keyimage() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageResponse.keyimage)
  if (!has_keyimage()) {
    return NULL;
  }
  clear_has_keyimage();
  return keyimage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinGenerateKeyimageResponse::set_allocated_keyimage(::std::string* keyimage) {
  if (keyimage != NULL) {
    set_has_keyimage();
  } else {
    clear_has_keyimage();
  }
  keyimage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keyimage);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinGenerateKeyimageResponse.keyimage)
}

// -------------------------------------------------------------------

// BytecoinGenerateOutputSeedRequest

// optional bytes tx_inputs_hash = 1;
inline bool BytecoinGenerateOutputSeedRequest::has_tx_inputs_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinGenerateOutputSeedRequest::set_has_tx_inputs_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinGenerateOutputSeedRequest::clear_has_tx_inputs_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinGenerateOutputSeedRequest::clear_tx_inputs_hash() {
  tx_inputs_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tx_inputs_hash();
}
inline const ::std::string& BytecoinGenerateOutputSeedRequest::tx_inputs_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedRequest.tx_inputs_hash)
  return tx_inputs_hash_.GetNoArena();
}
inline void BytecoinGenerateOutputSeedRequest::set_tx_inputs_hash(const ::std::string& value) {
  set_has_tx_inputs_hash();
  tx_inputs_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedRequest.tx_inputs_hash)
}
#if LANG_CXX11
inline void BytecoinGenerateOutputSeedRequest::set_tx_inputs_hash(::std::string&& value) {
  set_has_tx_inputs_hash();
  tx_inputs_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedRequest.tx_inputs_hash)
}
#endif
inline void BytecoinGenerateOutputSeedRequest::set_tx_inputs_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tx_inputs_hash();
  tx_inputs_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedRequest.tx_inputs_hash)
}
inline void BytecoinGenerateOutputSeedRequest::set_tx_inputs_hash(const void* value, size_t size) {
  set_has_tx_inputs_hash();
  tx_inputs_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedRequest.tx_inputs_hash)
}
inline ::std::string* BytecoinGenerateOutputSeedRequest::mutable_tx_inputs_hash() {
  set_has_tx_inputs_hash();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedRequest.tx_inputs_hash)
  return tx_inputs_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinGenerateOutputSeedRequest::release_tx_inputs_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedRequest.tx_inputs_hash)
  if (!has_tx_inputs_hash()) {
    return NULL;
  }
  clear_has_tx_inputs_hash();
  return tx_inputs_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinGenerateOutputSeedRequest::set_allocated_tx_inputs_hash(::std::string* tx_inputs_hash) {
  if (tx_inputs_hash != NULL) {
    set_has_tx_inputs_hash();
  } else {
    clear_has_tx_inputs_hash();
  }
  tx_inputs_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_inputs_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedRequest.tx_inputs_hash)
}

// optional uint32 out_index = 3;
inline bool BytecoinGenerateOutputSeedRequest::has_out_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytecoinGenerateOutputSeedRequest::set_has_out_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytecoinGenerateOutputSeedRequest::clear_has_out_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytecoinGenerateOutputSeedRequest::clear_out_index() {
  out_index_ = 0u;
  clear_has_out_index();
}
inline ::google::protobuf::uint32 BytecoinGenerateOutputSeedRequest::out_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedRequest.out_index)
  return out_index_;
}
inline void BytecoinGenerateOutputSeedRequest::set_out_index(::google::protobuf::uint32 value) {
  set_has_out_index();
  out_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedRequest.out_index)
}

// -------------------------------------------------------------------

// BytecoinGenerateOutputSeedResponse

// optional bytes output_seed = 1;
inline bool BytecoinGenerateOutputSeedResponse::has_output_seed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinGenerateOutputSeedResponse::set_has_output_seed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinGenerateOutputSeedResponse::clear_has_output_seed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinGenerateOutputSeedResponse::clear_output_seed() {
  output_seed_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_output_seed();
}
inline const ::std::string& BytecoinGenerateOutputSeedResponse::output_seed() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedResponse.output_seed)
  return output_seed_.GetNoArena();
}
inline void BytecoinGenerateOutputSeedResponse::set_output_seed(const ::std::string& value) {
  set_has_output_seed();
  output_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedResponse.output_seed)
}
#if LANG_CXX11
inline void BytecoinGenerateOutputSeedResponse::set_output_seed(::std::string&& value) {
  set_has_output_seed();
  output_seed_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedResponse.output_seed)
}
#endif
inline void BytecoinGenerateOutputSeedResponse::set_output_seed(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_output_seed();
  output_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedResponse.output_seed)
}
inline void BytecoinGenerateOutputSeedResponse::set_output_seed(const void* value, size_t size) {
  set_has_output_seed();
  output_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedResponse.output_seed)
}
inline ::std::string* BytecoinGenerateOutputSeedResponse::mutable_output_seed() {
  set_has_output_seed();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedResponse.output_seed)
  return output_seed_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinGenerateOutputSeedResponse::release_output_seed() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedResponse.output_seed)
  if (!has_output_seed()) {
    return NULL;
  }
  clear_has_output_seed();
  return output_seed_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinGenerateOutputSeedResponse::set_allocated_output_seed(::std::string* output_seed) {
  if (output_seed != NULL) {
    set_has_output_seed();
  } else {
    clear_has_output_seed();
  }
  output_seed_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_seed);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinGenerateOutputSeedResponse.output_seed)
}

// -------------------------------------------------------------------

// BytecoinExportViewWalletRequest

// -------------------------------------------------------------------

// BytecoinExportViewWalletResponse

// optional bytes audit_key_base_secret_key = 1;
inline bool BytecoinExportViewWalletResponse::has_audit_key_base_secret_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinExportViewWalletResponse::set_has_audit_key_base_secret_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinExportViewWalletResponse::clear_has_audit_key_base_secret_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinExportViewWalletResponse::clear_audit_key_base_secret_key() {
  audit_key_base_secret_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_audit_key_base_secret_key();
}
inline const ::std::string& BytecoinExportViewWalletResponse::audit_key_base_secret_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.audit_key_base_secret_key)
  return audit_key_base_secret_key_.GetNoArena();
}
inline void BytecoinExportViewWalletResponse::set_audit_key_base_secret_key(const ::std::string& value) {
  set_has_audit_key_base_secret_key();
  audit_key_base_secret_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.audit_key_base_secret_key)
}
#if LANG_CXX11
inline void BytecoinExportViewWalletResponse::set_audit_key_base_secret_key(::std::string&& value) {
  set_has_audit_key_base_secret_key();
  audit_key_base_secret_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.audit_key_base_secret_key)
}
#endif
inline void BytecoinExportViewWalletResponse::set_audit_key_base_secret_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_audit_key_base_secret_key();
  audit_key_base_secret_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.audit_key_base_secret_key)
}
inline void BytecoinExportViewWalletResponse::set_audit_key_base_secret_key(const void* value, size_t size) {
  set_has_audit_key_base_secret_key();
  audit_key_base_secret_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.audit_key_base_secret_key)
}
inline ::std::string* BytecoinExportViewWalletResponse::mutable_audit_key_base_secret_key() {
  set_has_audit_key_base_secret_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.audit_key_base_secret_key)
  return audit_key_base_secret_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinExportViewWalletResponse::release_audit_key_base_secret_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.audit_key_base_secret_key)
  if (!has_audit_key_base_secret_key()) {
    return NULL;
  }
  clear_has_audit_key_base_secret_key();
  return audit_key_base_secret_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinExportViewWalletResponse::set_allocated_audit_key_base_secret_key(::std::string* audit_key_base_secret_key) {
  if (audit_key_base_secret_key != NULL) {
    set_has_audit_key_base_secret_key();
  } else {
    clear_has_audit_key_base_secret_key();
  }
  audit_key_base_secret_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), audit_key_base_secret_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.audit_key_base_secret_key)
}

// optional bytes view_secret_key = 2;
inline bool BytecoinExportViewWalletResponse::has_view_secret_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytecoinExportViewWalletResponse::set_has_view_secret_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytecoinExportViewWalletResponse::clear_has_view_secret_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytecoinExportViewWalletResponse::clear_view_secret_key() {
  view_secret_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_view_secret_key();
}
inline const ::std::string& BytecoinExportViewWalletResponse::view_secret_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secret_key)
  return view_secret_key_.GetNoArena();
}
inline void BytecoinExportViewWalletResponse::set_view_secret_key(const ::std::string& value) {
  set_has_view_secret_key();
  view_secret_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secret_key)
}
#if LANG_CXX11
inline void BytecoinExportViewWalletResponse::set_view_secret_key(::std::string&& value) {
  set_has_view_secret_key();
  view_secret_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secret_key)
}
#endif
inline void BytecoinExportViewWalletResponse::set_view_secret_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_view_secret_key();
  view_secret_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secret_key)
}
inline void BytecoinExportViewWalletResponse::set_view_secret_key(const void* value, size_t size) {
  set_has_view_secret_key();
  view_secret_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secret_key)
}
inline ::std::string* BytecoinExportViewWalletResponse::mutable_view_secret_key() {
  set_has_view_secret_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secret_key)
  return view_secret_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinExportViewWalletResponse::release_view_secret_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secret_key)
  if (!has_view_secret_key()) {
    return NULL;
  }
  clear_has_view_secret_key();
  return view_secret_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinExportViewWalletResponse::set_allocated_view_secret_key(::std::string* view_secret_key) {
  if (view_secret_key != NULL) {
    set_has_view_secret_key();
  } else {
    clear_has_view_secret_key();
  }
  view_secret_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), view_secret_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secret_key)
}

// optional bytes tx_derivation_seed = 3;
inline bool BytecoinExportViewWalletResponse::has_tx_derivation_seed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BytecoinExportViewWalletResponse::set_has_tx_derivation_seed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BytecoinExportViewWalletResponse::clear_has_tx_derivation_seed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BytecoinExportViewWalletResponse::clear_tx_derivation_seed() {
  tx_derivation_seed_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tx_derivation_seed();
}
inline const ::std::string& BytecoinExportViewWalletResponse::tx_derivation_seed() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.tx_derivation_seed)
  return tx_derivation_seed_.GetNoArena();
}
inline void BytecoinExportViewWalletResponse::set_tx_derivation_seed(const ::std::string& value) {
  set_has_tx_derivation_seed();
  tx_derivation_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.tx_derivation_seed)
}
#if LANG_CXX11
inline void BytecoinExportViewWalletResponse::set_tx_derivation_seed(::std::string&& value) {
  set_has_tx_derivation_seed();
  tx_derivation_seed_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.tx_derivation_seed)
}
#endif
inline void BytecoinExportViewWalletResponse::set_tx_derivation_seed(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tx_derivation_seed();
  tx_derivation_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.tx_derivation_seed)
}
inline void BytecoinExportViewWalletResponse::set_tx_derivation_seed(const void* value, size_t size) {
  set_has_tx_derivation_seed();
  tx_derivation_seed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.tx_derivation_seed)
}
inline ::std::string* BytecoinExportViewWalletResponse::mutable_tx_derivation_seed() {
  set_has_tx_derivation_seed();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.tx_derivation_seed)
  return tx_derivation_seed_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinExportViewWalletResponse::release_tx_derivation_seed() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.tx_derivation_seed)
  if (!has_tx_derivation_seed()) {
    return NULL;
  }
  clear_has_tx_derivation_seed();
  return tx_derivation_seed_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinExportViewWalletResponse::set_allocated_tx_derivation_seed(::std::string* tx_derivation_seed) {
  if (tx_derivation_seed != NULL) {
    set_has_tx_derivation_seed();
  } else {
    clear_has_tx_derivation_seed();
  }
  tx_derivation_seed_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_derivation_seed);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.tx_derivation_seed)
}

// optional bytes view_secrets_signature = 4;
inline bool BytecoinExportViewWalletResponse::has_view_secrets_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BytecoinExportViewWalletResponse::set_has_view_secrets_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BytecoinExportViewWalletResponse::clear_has_view_secrets_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BytecoinExportViewWalletResponse::clear_view_secrets_signature() {
  view_secrets_signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_view_secrets_signature();
}
inline const ::std::string& BytecoinExportViewWalletResponse::view_secrets_signature() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secrets_signature)
  return view_secrets_signature_.GetNoArena();
}
inline void BytecoinExportViewWalletResponse::set_view_secrets_signature(const ::std::string& value) {
  set_has_view_secrets_signature();
  view_secrets_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secrets_signature)
}
#if LANG_CXX11
inline void BytecoinExportViewWalletResponse::set_view_secrets_signature(::std::string&& value) {
  set_has_view_secrets_signature();
  view_secrets_signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secrets_signature)
}
#endif
inline void BytecoinExportViewWalletResponse::set_view_secrets_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_view_secrets_signature();
  view_secrets_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secrets_signature)
}
inline void BytecoinExportViewWalletResponse::set_view_secrets_signature(const void* value, size_t size) {
  set_has_view_secrets_signature();
  view_secrets_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secrets_signature)
}
inline ::std::string* BytecoinExportViewWalletResponse::mutable_view_secrets_signature() {
  set_has_view_secrets_signature();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secrets_signature)
  return view_secrets_signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinExportViewWalletResponse::release_view_secrets_signature() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secrets_signature)
  if (!has_view_secrets_signature()) {
    return NULL;
  }
  clear_has_view_secrets_signature();
  return view_secrets_signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinExportViewWalletResponse::set_allocated_view_secrets_signature(::std::string* view_secrets_signature) {
  if (view_secrets_signature != NULL) {
    set_has_view_secrets_signature();
  } else {
    clear_has_view_secrets_signature();
  }
  view_secrets_signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), view_secrets_signature);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinExportViewWalletResponse.view_secrets_signature)
}

// -------------------------------------------------------------------

// BytecoinSignStartRequest

// optional uint32 version = 1;
inline bool BytecoinSignStartRequest::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytecoinSignStartRequest::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytecoinSignStartRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytecoinSignStartRequest::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 BytecoinSignStartRequest::version() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStartRequest.version)
  return version_;
}
inline void BytecoinSignStartRequest::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStartRequest.version)
}

// optional uint64 ut = 2;
inline bool BytecoinSignStartRequest::has_ut() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinSignStartRequest::set_has_ut() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinSignStartRequest::clear_has_ut() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinSignStartRequest::clear_ut() {
  ut_ = GOOGLE_ULONGLONG(0);
  clear_has_ut();
}
inline ::google::protobuf::uint64 BytecoinSignStartRequest::ut() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStartRequest.ut)
  return ut_;
}
inline void BytecoinSignStartRequest::set_ut(::google::protobuf::uint64 value) {
  set_has_ut();
  ut_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStartRequest.ut)
}

// optional uint32 inputs_size = 3;
inline bool BytecoinSignStartRequest::has_inputs_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BytecoinSignStartRequest::set_has_inputs_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BytecoinSignStartRequest::clear_has_inputs_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BytecoinSignStartRequest::clear_inputs_size() {
  inputs_size_ = 0u;
  clear_has_inputs_size();
}
inline ::google::protobuf::uint32 BytecoinSignStartRequest::inputs_size() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStartRequest.inputs_size)
  return inputs_size_;
}
inline void BytecoinSignStartRequest::set_inputs_size(::google::protobuf::uint32 value) {
  set_has_inputs_size();
  inputs_size_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStartRequest.inputs_size)
}

// optional uint32 outputs_size = 4;
inline bool BytecoinSignStartRequest::has_outputs_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BytecoinSignStartRequest::set_has_outputs_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BytecoinSignStartRequest::clear_has_outputs_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BytecoinSignStartRequest::clear_outputs_size() {
  outputs_size_ = 0u;
  clear_has_outputs_size();
}
inline ::google::protobuf::uint32 BytecoinSignStartRequest::outputs_size() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStartRequest.outputs_size)
  return outputs_size_;
}
inline void BytecoinSignStartRequest::set_outputs_size(::google::protobuf::uint32 value) {
  set_has_outputs_size();
  outputs_size_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStartRequest.outputs_size)
}

// optional uint32 extra_size = 5;
inline bool BytecoinSignStartRequest::has_extra_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BytecoinSignStartRequest::set_has_extra_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BytecoinSignStartRequest::clear_has_extra_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BytecoinSignStartRequest::clear_extra_size() {
  extra_size_ = 0u;
  clear_has_extra_size();
}
inline ::google::protobuf::uint32 BytecoinSignStartRequest::extra_size() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStartRequest.extra_size)
  return extra_size_;
}
inline void BytecoinSignStartRequest::set_extra_size(::google::protobuf::uint32 value) {
  set_has_extra_size();
  extra_size_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStartRequest.extra_size)
}

// -------------------------------------------------------------------

// BytecoinEmptyResponse

// -------------------------------------------------------------------

// BytecoinSignAddInputRequest

// optional uint64 amount = 1;
inline bool BytecoinSignAddInputRequest::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytecoinSignAddInputRequest::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytecoinSignAddInputRequest::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytecoinSignAddInputRequest::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BytecoinSignAddInputRequest::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.amount)
  return amount_;
}
inline void BytecoinSignAddInputRequest::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.amount)
}

// repeated uint32 output_indexes = 2;
inline int BytecoinSignAddInputRequest::output_indexes_size() const {
  return output_indexes_.size();
}
inline void BytecoinSignAddInputRequest::clear_output_indexes() {
  output_indexes_.Clear();
}
inline ::google::protobuf::uint32 BytecoinSignAddInputRequest::output_indexes(int index) const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.output_indexes)
  return output_indexes_.Get(index);
}
inline void BytecoinSignAddInputRequest::set_output_indexes(int index, ::google::protobuf::uint32 value) {
  output_indexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.output_indexes)
}
inline void BytecoinSignAddInputRequest::add_output_indexes(::google::protobuf::uint32 value) {
  output_indexes_.Add(value);
  // @@protoc_insertion_point(field_add:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.output_indexes)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BytecoinSignAddInputRequest::output_indexes() const {
  // @@protoc_insertion_point(field_list:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.output_indexes)
  return output_indexes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BytecoinSignAddInputRequest::mutable_output_indexes() {
  // @@protoc_insertion_point(field_mutable_list:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.output_indexes)
  return &output_indexes_;
}

// optional bytes inv_output_main_hash = 3;
inline bool BytecoinSignAddInputRequest::has_inv_output_main_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinSignAddInputRequest::set_has_inv_output_main_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinSignAddInputRequest::clear_has_inv_output_main_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinSignAddInputRequest::clear_inv_output_main_hash() {
  inv_output_main_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_inv_output_main_hash();
}
inline const ::std::string& BytecoinSignAddInputRequest::inv_output_main_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.inv_output_main_hash)
  return inv_output_main_hash_.GetNoArena();
}
inline void BytecoinSignAddInputRequest::set_inv_output_main_hash(const ::std::string& value) {
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.inv_output_main_hash)
}
#if LANG_CXX11
inline void BytecoinSignAddInputRequest::set_inv_output_main_hash(::std::string&& value) {
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.inv_output_main_hash)
}
#endif
inline void BytecoinSignAddInputRequest::set_inv_output_main_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.inv_output_main_hash)
}
inline void BytecoinSignAddInputRequest::set_inv_output_main_hash(const void* value, size_t size) {
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.inv_output_main_hash)
}
inline ::std::string* BytecoinSignAddInputRequest::mutable_inv_output_main_hash() {
  set_has_inv_output_main_hash();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.inv_output_main_hash)
  return inv_output_main_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignAddInputRequest::release_inv_output_main_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.inv_output_main_hash)
  if (!has_inv_output_main_hash()) {
    return NULL;
  }
  clear_has_inv_output_main_hash();
  return inv_output_main_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignAddInputRequest::set_allocated_inv_output_main_hash(::std::string* inv_output_main_hash) {
  if (inv_output_main_hash != NULL) {
    set_has_inv_output_main_hash();
  } else {
    clear_has_inv_output_main_hash();
  }
  inv_output_main_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), inv_output_main_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.inv_output_main_hash)
}

// optional uint32 address_index = 4;
inline bool BytecoinSignAddInputRequest::has_address_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BytecoinSignAddInputRequest::set_has_address_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BytecoinSignAddInputRequest::clear_has_address_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BytecoinSignAddInputRequest::clear_address_index() {
  address_index_ = 0u;
  clear_has_address_index();
}
inline ::google::protobuf::uint32 BytecoinSignAddInputRequest::address_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.address_index)
  return address_index_;
}
inline void BytecoinSignAddInputRequest::set_address_index(::google::protobuf::uint32 value) {
  set_has_address_index();
  address_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddInputRequest.address_index)
}

// -------------------------------------------------------------------

// BytecoinSignAddOutputRequest

// optional bool change = 1;
inline bool BytecoinSignAddOutputRequest::has_change() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BytecoinSignAddOutputRequest::set_has_change() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BytecoinSignAddOutputRequest::clear_has_change() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BytecoinSignAddOutputRequest::clear_change() {
  change_ = false;
  clear_has_change();
}
inline bool BytecoinSignAddOutputRequest::change() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.change)
  return change_;
}
inline void BytecoinSignAddOutputRequest::set_change(bool value) {
  set_has_change();
  change_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.change)
}

// optional uint64 amount = 2;
inline bool BytecoinSignAddOutputRequest::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BytecoinSignAddOutputRequest::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BytecoinSignAddOutputRequest::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BytecoinSignAddOutputRequest::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 BytecoinSignAddOutputRequest::amount() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.amount)
  return amount_;
}
inline void BytecoinSignAddOutputRequest::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.amount)
}

// optional uint32 dst_address_tag = 3;
inline bool BytecoinSignAddOutputRequest::has_dst_address_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BytecoinSignAddOutputRequest::set_has_dst_address_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BytecoinSignAddOutputRequest::clear_has_dst_address_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BytecoinSignAddOutputRequest::clear_dst_address_tag() {
  dst_address_tag_ = 0u;
  clear_has_dst_address_tag();
}
inline ::google::protobuf::uint32 BytecoinSignAddOutputRequest::dst_address_tag() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_tag)
  return dst_address_tag_;
}
inline void BytecoinSignAddOutputRequest::set_dst_address_tag(::google::protobuf::uint32 value) {
  set_has_dst_address_tag();
  dst_address_tag_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_tag)
}

// optional bytes dst_address_S = 4;
inline bool BytecoinSignAddOutputRequest::has_dst_address_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinSignAddOutputRequest::set_has_dst_address_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinSignAddOutputRequest::clear_has_dst_address_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinSignAddOutputRequest::clear_dst_address_s() {
  dst_address_s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dst_address_s();
}
inline const ::std::string& BytecoinSignAddOutputRequest::dst_address_s() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_S)
  return dst_address_s_.GetNoArena();
}
inline void BytecoinSignAddOutputRequest::set_dst_address_s(const ::std::string& value) {
  set_has_dst_address_s();
  dst_address_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_S)
}
#if LANG_CXX11
inline void BytecoinSignAddOutputRequest::set_dst_address_s(::std::string&& value) {
  set_has_dst_address_s();
  dst_address_s_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_S)
}
#endif
inline void BytecoinSignAddOutputRequest::set_dst_address_s(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dst_address_s();
  dst_address_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_S)
}
inline void BytecoinSignAddOutputRequest::set_dst_address_s(const void* value, size_t size) {
  set_has_dst_address_s();
  dst_address_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_S)
}
inline ::std::string* BytecoinSignAddOutputRequest::mutable_dst_address_s() {
  set_has_dst_address_s();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_S)
  return dst_address_s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignAddOutputRequest::release_dst_address_s() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_S)
  if (!has_dst_address_s()) {
    return NULL;
  }
  clear_has_dst_address_s();
  return dst_address_s_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignAddOutputRequest::set_allocated_dst_address_s(::std::string* dst_address_s) {
  if (dst_address_s != NULL) {
    set_has_dst_address_s();
  } else {
    clear_has_dst_address_s();
  }
  dst_address_s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dst_address_s);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_S)
}

// optional bytes dst_address_Sv = 5;
inline bool BytecoinSignAddOutputRequest::has_dst_address_sv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytecoinSignAddOutputRequest::set_has_dst_address_sv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytecoinSignAddOutputRequest::clear_has_dst_address_sv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytecoinSignAddOutputRequest::clear_dst_address_sv() {
  dst_address_sv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dst_address_sv();
}
inline const ::std::string& BytecoinSignAddOutputRequest::dst_address_sv() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_Sv)
  return dst_address_sv_.GetNoArena();
}
inline void BytecoinSignAddOutputRequest::set_dst_address_sv(const ::std::string& value) {
  set_has_dst_address_sv();
  dst_address_sv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_Sv)
}
#if LANG_CXX11
inline void BytecoinSignAddOutputRequest::set_dst_address_sv(::std::string&& value) {
  set_has_dst_address_sv();
  dst_address_sv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_Sv)
}
#endif
inline void BytecoinSignAddOutputRequest::set_dst_address_sv(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dst_address_sv();
  dst_address_sv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_Sv)
}
inline void BytecoinSignAddOutputRequest::set_dst_address_sv(const void* value, size_t size) {
  set_has_dst_address_sv();
  dst_address_sv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_Sv)
}
inline ::std::string* BytecoinSignAddOutputRequest::mutable_dst_address_sv() {
  set_has_dst_address_sv();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_Sv)
  return dst_address_sv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignAddOutputRequest::release_dst_address_sv() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_Sv)
  if (!has_dst_address_sv()) {
    return NULL;
  }
  clear_has_dst_address_sv();
  return dst_address_sv_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignAddOutputRequest::set_allocated_dst_address_sv(::std::string* dst_address_sv) {
  if (dst_address_sv != NULL) {
    set_has_dst_address_sv();
  } else {
    clear_has_dst_address_sv();
  }
  dst_address_sv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dst_address_sv);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.dst_address_Sv)
}

// optional uint32 change_address_index = 6;
inline bool BytecoinSignAddOutputRequest::has_change_address_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BytecoinSignAddOutputRequest::set_has_change_address_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BytecoinSignAddOutputRequest::clear_has_change_address_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BytecoinSignAddOutputRequest::clear_change_address_index() {
  change_address_index_ = 0u;
  clear_has_change_address_index();
}
inline ::google::protobuf::uint32 BytecoinSignAddOutputRequest::change_address_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.change_address_index)
  return change_address_index_;
}
inline void BytecoinSignAddOutputRequest::set_change_address_index(::google::protobuf::uint32 value) {
  set_has_change_address_index();
  change_address_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddOutputRequest.change_address_index)
}

// -------------------------------------------------------------------

// BytecoinSignAddOutputResponse

// optional bytes public_key = 1;
inline bool BytecoinSignAddOutputResponse::has_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinSignAddOutputResponse::set_has_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinSignAddOutputResponse::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinSignAddOutputResponse::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
inline const ::std::string& BytecoinSignAddOutputResponse::public_key() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.public_key)
  return public_key_.GetNoArena();
}
inline void BytecoinSignAddOutputResponse::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.public_key)
}
#if LANG_CXX11
inline void BytecoinSignAddOutputResponse::set_public_key(::std::string&& value) {
  set_has_public_key();
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.public_key)
}
#endif
inline void BytecoinSignAddOutputResponse::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.public_key)
}
inline void BytecoinSignAddOutputResponse::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.public_key)
}
inline ::std::string* BytecoinSignAddOutputResponse::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignAddOutputResponse::release_public_key() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.public_key)
  if (!has_public_key()) {
    return NULL;
  }
  clear_has_public_key();
  return public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignAddOutputResponse::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.public_key)
}

// optional bytes encrypted_secret = 2;
inline bool BytecoinSignAddOutputResponse::has_encrypted_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytecoinSignAddOutputResponse::set_has_encrypted_secret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytecoinSignAddOutputResponse::clear_has_encrypted_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytecoinSignAddOutputResponse::clear_encrypted_secret() {
  encrypted_secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_encrypted_secret();
}
inline const ::std::string& BytecoinSignAddOutputResponse::encrypted_secret() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.encrypted_secret)
  return encrypted_secret_.GetNoArena();
}
inline void BytecoinSignAddOutputResponse::set_encrypted_secret(const ::std::string& value) {
  set_has_encrypted_secret();
  encrypted_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.encrypted_secret)
}
#if LANG_CXX11
inline void BytecoinSignAddOutputResponse::set_encrypted_secret(::std::string&& value) {
  set_has_encrypted_secret();
  encrypted_secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.encrypted_secret)
}
#endif
inline void BytecoinSignAddOutputResponse::set_encrypted_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_encrypted_secret();
  encrypted_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.encrypted_secret)
}
inline void BytecoinSignAddOutputResponse::set_encrypted_secret(const void* value, size_t size) {
  set_has_encrypted_secret();
  encrypted_secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.encrypted_secret)
}
inline ::std::string* BytecoinSignAddOutputResponse::mutable_encrypted_secret() {
  set_has_encrypted_secret();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.encrypted_secret)
  return encrypted_secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignAddOutputResponse::release_encrypted_secret() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.encrypted_secret)
  if (!has_encrypted_secret()) {
    return NULL;
  }
  clear_has_encrypted_secret();
  return encrypted_secret_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignAddOutputResponse::set_allocated_encrypted_secret(::std::string* encrypted_secret) {
  if (encrypted_secret != NULL) {
    set_has_encrypted_secret();
  } else {
    clear_has_encrypted_secret();
  }
  encrypted_secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encrypted_secret);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.encrypted_secret)
}

// optional uint32 encrypted_address_type = 3;
inline bool BytecoinSignAddOutputResponse::has_encrypted_address_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BytecoinSignAddOutputResponse::set_has_encrypted_address_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BytecoinSignAddOutputResponse::clear_has_encrypted_address_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BytecoinSignAddOutputResponse::clear_encrypted_address_type() {
  encrypted_address_type_ = 0u;
  clear_has_encrypted_address_type();
}
inline ::google::protobuf::uint32 BytecoinSignAddOutputResponse::encrypted_address_type() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.encrypted_address_type)
  return encrypted_address_type_;
}
inline void BytecoinSignAddOutputResponse::set_encrypted_address_type(::google::protobuf::uint32 value) {
  set_has_encrypted_address_type();
  encrypted_address_type_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddOutputResponse.encrypted_address_type)
}

// -------------------------------------------------------------------

// BytecoinSignAddExtraRequest

// optional bytes extra_chunk = 1;
inline bool BytecoinSignAddExtraRequest::has_extra_chunk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinSignAddExtraRequest::set_has_extra_chunk() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinSignAddExtraRequest::clear_has_extra_chunk() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinSignAddExtraRequest::clear_extra_chunk() {
  extra_chunk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extra_chunk();
}
inline const ::std::string& BytecoinSignAddExtraRequest::extra_chunk() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignAddExtraRequest.extra_chunk)
  return extra_chunk_.GetNoArena();
}
inline void BytecoinSignAddExtraRequest::set_extra_chunk(const ::std::string& value) {
  set_has_extra_chunk();
  extra_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignAddExtraRequest.extra_chunk)
}
#if LANG_CXX11
inline void BytecoinSignAddExtraRequest::set_extra_chunk(::std::string&& value) {
  set_has_extra_chunk();
  extra_chunk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignAddExtraRequest.extra_chunk)
}
#endif
inline void BytecoinSignAddExtraRequest::set_extra_chunk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_extra_chunk();
  extra_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignAddExtraRequest.extra_chunk)
}
inline void BytecoinSignAddExtraRequest::set_extra_chunk(const void* value, size_t size) {
  set_has_extra_chunk();
  extra_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignAddExtraRequest.extra_chunk)
}
inline ::std::string* BytecoinSignAddExtraRequest::mutable_extra_chunk() {
  set_has_extra_chunk();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignAddExtraRequest.extra_chunk)
  return extra_chunk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignAddExtraRequest::release_extra_chunk() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignAddExtraRequest.extra_chunk)
  if (!has_extra_chunk()) {
    return NULL;
  }
  clear_has_extra_chunk();
  return extra_chunk_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignAddExtraRequest::set_allocated_extra_chunk(::std::string* extra_chunk) {
  if (extra_chunk != NULL) {
    set_has_extra_chunk();
  } else {
    clear_has_extra_chunk();
  }
  extra_chunk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extra_chunk);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignAddExtraRequest.extra_chunk)
}

// -------------------------------------------------------------------

// BytecoinSignStepARequest

// optional bytes inv_output_main_hash = 1;
inline bool BytecoinSignStepARequest::has_inv_output_main_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinSignStepARequest::set_has_inv_output_main_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinSignStepARequest::clear_has_inv_output_main_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinSignStepARequest::clear_inv_output_main_hash() {
  inv_output_main_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_inv_output_main_hash();
}
inline const ::std::string& BytecoinSignStepARequest::inv_output_main_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStepARequest.inv_output_main_hash)
  return inv_output_main_hash_.GetNoArena();
}
inline void BytecoinSignStepARequest::set_inv_output_main_hash(const ::std::string& value) {
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStepARequest.inv_output_main_hash)
}
#if LANG_CXX11
inline void BytecoinSignStepARequest::set_inv_output_main_hash(::std::string&& value) {
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignStepARequest.inv_output_main_hash)
}
#endif
inline void BytecoinSignStepARequest::set_inv_output_main_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignStepARequest.inv_output_main_hash)
}
inline void BytecoinSignStepARequest::set_inv_output_main_hash(const void* value, size_t size) {
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignStepARequest.inv_output_main_hash)
}
inline ::std::string* BytecoinSignStepARequest::mutable_inv_output_main_hash() {
  set_has_inv_output_main_hash();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignStepARequest.inv_output_main_hash)
  return inv_output_main_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignStepARequest::release_inv_output_main_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignStepARequest.inv_output_main_hash)
  if (!has_inv_output_main_hash()) {
    return NULL;
  }
  clear_has_inv_output_main_hash();
  return inv_output_main_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignStepARequest::set_allocated_inv_output_main_hash(::std::string* inv_output_main_hash) {
  if (inv_output_main_hash != NULL) {
    set_has_inv_output_main_hash();
  } else {
    clear_has_inv_output_main_hash();
  }
  inv_output_main_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), inv_output_main_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignStepARequest.inv_output_main_hash)
}

// optional uint64 address_index = 2;
inline bool BytecoinSignStepARequest::has_address_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytecoinSignStepARequest::set_has_address_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytecoinSignStepARequest::clear_has_address_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytecoinSignStepARequest::clear_address_index() {
  address_index_ = GOOGLE_ULONGLONG(0);
  clear_has_address_index();
}
inline ::google::protobuf::uint64 BytecoinSignStepARequest::address_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStepARequest.address_index)
  return address_index_;
}
inline void BytecoinSignStepARequest::set_address_index(::google::protobuf::uint64 value) {
  set_has_address_index();
  address_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStepARequest.address_index)
}

// -------------------------------------------------------------------

// BytecoinSignStepAResponse

// optional bytes sig_p = 1;
inline bool BytecoinSignStepAResponse::has_sig_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinSignStepAResponse::set_has_sig_p() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinSignStepAResponse::clear_has_sig_p() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinSignStepAResponse::clear_sig_p() {
  sig_p_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sig_p();
}
inline const ::std::string& BytecoinSignStepAResponse::sig_p() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.sig_p)
  return sig_p_.GetNoArena();
}
inline void BytecoinSignStepAResponse::set_sig_p(const ::std::string& value) {
  set_has_sig_p();
  sig_p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.sig_p)
}
#if LANG_CXX11
inline void BytecoinSignStepAResponse::set_sig_p(::std::string&& value) {
  set_has_sig_p();
  sig_p_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.sig_p)
}
#endif
inline void BytecoinSignStepAResponse::set_sig_p(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sig_p();
  sig_p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.sig_p)
}
inline void BytecoinSignStepAResponse::set_sig_p(const void* value, size_t size) {
  set_has_sig_p();
  sig_p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.sig_p)
}
inline ::std::string* BytecoinSignStepAResponse::mutable_sig_p() {
  set_has_sig_p();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.sig_p)
  return sig_p_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignStepAResponse::release_sig_p() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.sig_p)
  if (!has_sig_p()) {
    return NULL;
  }
  clear_has_sig_p();
  return sig_p_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignStepAResponse::set_allocated_sig_p(::std::string* sig_p) {
  if (sig_p != NULL) {
    set_has_sig_p();
  } else {
    clear_has_sig_p();
  }
  sig_p_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sig_p);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.sig_p)
}

// optional bytes x = 2;
inline bool BytecoinSignStepAResponse::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytecoinSignStepAResponse::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytecoinSignStepAResponse::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytecoinSignStepAResponse::clear_x() {
  x_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_x();
}
inline const ::std::string& BytecoinSignStepAResponse::x() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.x)
  return x_.GetNoArena();
}
inline void BytecoinSignStepAResponse::set_x(const ::std::string& value) {
  set_has_x();
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.x)
}
#if LANG_CXX11
inline void BytecoinSignStepAResponse::set_x(::std::string&& value) {
  set_has_x();
  x_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.x)
}
#endif
inline void BytecoinSignStepAResponse::set_x(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_x();
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.x)
}
inline void BytecoinSignStepAResponse::set_x(const void* value, size_t size) {
  set_has_x();
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.x)
}
inline ::std::string* BytecoinSignStepAResponse::mutable_x() {
  set_has_x();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.x)
  return x_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignStepAResponse::release_x() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.x)
  if (!has_x()) {
    return NULL;
  }
  clear_has_x();
  return x_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignStepAResponse::set_allocated_x(::std::string* x) {
  if (x != NULL) {
    set_has_x();
  } else {
    clear_has_x();
  }
  x_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), x);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.x)
}

// optional bytes y = 3;
inline bool BytecoinSignStepAResponse::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BytecoinSignStepAResponse::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BytecoinSignStepAResponse::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BytecoinSignStepAResponse::clear_y() {
  y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_y();
}
inline const ::std::string& BytecoinSignStepAResponse::y() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.y)
  return y_.GetNoArena();
}
inline void BytecoinSignStepAResponse::set_y(const ::std::string& value) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.y)
}
#if LANG_CXX11
inline void BytecoinSignStepAResponse::set_y(::std::string&& value) {
  set_has_y();
  y_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.y)
}
#endif
inline void BytecoinSignStepAResponse::set_y(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.y)
}
inline void BytecoinSignStepAResponse::set_y(const void* value, size_t size) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.y)
}
inline ::std::string* BytecoinSignStepAResponse::mutable_y() {
  set_has_y();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.y)
  return y_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignStepAResponse::release_y() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.y)
  if (!has_y()) {
    return NULL;
  }
  clear_has_y();
  return y_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignStepAResponse::set_allocated_y(::std::string* y) {
  if (y != NULL) {
    set_has_y();
  } else {
    clear_has_y();
  }
  y_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignStepAResponse.y)
}

// -------------------------------------------------------------------

// BytecoinSignStepAMoreDataRequest

// optional bytes data_chunk = 1;
inline bool BytecoinSignStepAMoreDataRequest::has_data_chunk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinSignStepAMoreDataRequest::set_has_data_chunk() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinSignStepAMoreDataRequest::clear_has_data_chunk() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinSignStepAMoreDataRequest::clear_data_chunk() {
  data_chunk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_chunk();
}
inline const ::std::string& BytecoinSignStepAMoreDataRequest::data_chunk() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStepAMoreDataRequest.data_chunk)
  return data_chunk_.GetNoArena();
}
inline void BytecoinSignStepAMoreDataRequest::set_data_chunk(const ::std::string& value) {
  set_has_data_chunk();
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStepAMoreDataRequest.data_chunk)
}
#if LANG_CXX11
inline void BytecoinSignStepAMoreDataRequest::set_data_chunk(::std::string&& value) {
  set_has_data_chunk();
  data_chunk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignStepAMoreDataRequest.data_chunk)
}
#endif
inline void BytecoinSignStepAMoreDataRequest::set_data_chunk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_chunk();
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignStepAMoreDataRequest.data_chunk)
}
inline void BytecoinSignStepAMoreDataRequest::set_data_chunk(const void* value, size_t size) {
  set_has_data_chunk();
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignStepAMoreDataRequest.data_chunk)
}
inline ::std::string* BytecoinSignStepAMoreDataRequest::mutable_data_chunk() {
  set_has_data_chunk();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignStepAMoreDataRequest.data_chunk)
  return data_chunk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignStepAMoreDataRequest::release_data_chunk() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignStepAMoreDataRequest.data_chunk)
  if (!has_data_chunk()) {
    return NULL;
  }
  clear_has_data_chunk();
  return data_chunk_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignStepAMoreDataRequest::set_allocated_data_chunk(::std::string* data_chunk) {
  if (data_chunk != NULL) {
    set_has_data_chunk();
  } else {
    clear_has_data_chunk();
  }
  data_chunk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_chunk);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignStepAMoreDataRequest.data_chunk)
}

// -------------------------------------------------------------------

// BytecoinSignGetC0Request

// -------------------------------------------------------------------

// BytecoinSignGetC0Response

// optional bytes c0 = 1;
inline bool BytecoinSignGetC0Response::has_c0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinSignGetC0Response::set_has_c0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinSignGetC0Response::clear_has_c0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinSignGetC0Response::clear_c0() {
  c0_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_c0();
}
inline const ::std::string& BytecoinSignGetC0Response::c0() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignGetC0Response.c0)
  return c0_.GetNoArena();
}
inline void BytecoinSignGetC0Response::set_c0(const ::std::string& value) {
  set_has_c0();
  c0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignGetC0Response.c0)
}
#if LANG_CXX11
inline void BytecoinSignGetC0Response::set_c0(::std::string&& value) {
  set_has_c0();
  c0_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignGetC0Response.c0)
}
#endif
inline void BytecoinSignGetC0Response::set_c0(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_c0();
  c0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignGetC0Response.c0)
}
inline void BytecoinSignGetC0Response::set_c0(const void* value, size_t size) {
  set_has_c0();
  c0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignGetC0Response.c0)
}
inline ::std::string* BytecoinSignGetC0Response::mutable_c0() {
  set_has_c0();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignGetC0Response.c0)
  return c0_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignGetC0Response::release_c0() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignGetC0Response.c0)
  if (!has_c0()) {
    return NULL;
  }
  clear_has_c0();
  return c0_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignGetC0Response::set_allocated_c0(::std::string* c0) {
  if (c0 != NULL) {
    set_has_c0();
  } else {
    clear_has_c0();
  }
  c0_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), c0);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignGetC0Response.c0)
}

// -------------------------------------------------------------------

// BytecoinSignStepBRequest

// optional bytes inv_output_main_hash = 1;
inline bool BytecoinSignStepBRequest::has_inv_output_main_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinSignStepBRequest::set_has_inv_output_main_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinSignStepBRequest::clear_has_inv_output_main_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinSignStepBRequest::clear_inv_output_main_hash() {
  inv_output_main_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_inv_output_main_hash();
}
inline const ::std::string& BytecoinSignStepBRequest::inv_output_main_hash() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.inv_output_main_hash)
  return inv_output_main_hash_.GetNoArena();
}
inline void BytecoinSignStepBRequest::set_inv_output_main_hash(const ::std::string& value) {
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.inv_output_main_hash)
}
#if LANG_CXX11
inline void BytecoinSignStepBRequest::set_inv_output_main_hash(::std::string&& value) {
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.inv_output_main_hash)
}
#endif
inline void BytecoinSignStepBRequest::set_inv_output_main_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.inv_output_main_hash)
}
inline void BytecoinSignStepBRequest::set_inv_output_main_hash(const void* value, size_t size) {
  set_has_inv_output_main_hash();
  inv_output_main_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.inv_output_main_hash)
}
inline ::std::string* BytecoinSignStepBRequest::mutable_inv_output_main_hash() {
  set_has_inv_output_main_hash();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.inv_output_main_hash)
  return inv_output_main_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignStepBRequest::release_inv_output_main_hash() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.inv_output_main_hash)
  if (!has_inv_output_main_hash()) {
    return NULL;
  }
  clear_has_inv_output_main_hash();
  return inv_output_main_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignStepBRequest::set_allocated_inv_output_main_hash(::std::string* inv_output_main_hash) {
  if (inv_output_main_hash != NULL) {
    set_has_inv_output_main_hash();
  } else {
    clear_has_inv_output_main_hash();
  }
  inv_output_main_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), inv_output_main_hash);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.inv_output_main_hash)
}

// optional uint64 address_index = 2;
inline bool BytecoinSignStepBRequest::has_address_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BytecoinSignStepBRequest::set_has_address_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BytecoinSignStepBRequest::clear_has_address_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BytecoinSignStepBRequest::clear_address_index() {
  address_index_ = GOOGLE_ULONGLONG(0);
  clear_has_address_index();
}
inline ::google::protobuf::uint64 BytecoinSignStepBRequest::address_index() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.address_index)
  return address_index_;
}
inline void BytecoinSignStepBRequest::set_address_index(::google::protobuf::uint64 value) {
  set_has_address_index();
  address_index_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.address_index)
}

// optional bytes my_c = 3;
inline bool BytecoinSignStepBRequest::has_my_c() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytecoinSignStepBRequest::set_has_my_c() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytecoinSignStepBRequest::clear_has_my_c() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytecoinSignStepBRequest::clear_my_c() {
  my_c_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_my_c();
}
inline const ::std::string& BytecoinSignStepBRequest::my_c() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.my_c)
  return my_c_.GetNoArena();
}
inline void BytecoinSignStepBRequest::set_my_c(const ::std::string& value) {
  set_has_my_c();
  my_c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.my_c)
}
#if LANG_CXX11
inline void BytecoinSignStepBRequest::set_my_c(::std::string&& value) {
  set_has_my_c();
  my_c_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.my_c)
}
#endif
inline void BytecoinSignStepBRequest::set_my_c(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_my_c();
  my_c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.my_c)
}
inline void BytecoinSignStepBRequest::set_my_c(const void* value, size_t size) {
  set_has_my_c();
  my_c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.my_c)
}
inline ::std::string* BytecoinSignStepBRequest::mutable_my_c() {
  set_has_my_c();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.my_c)
  return my_c_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignStepBRequest::release_my_c() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.my_c)
  if (!has_my_c()) {
    return NULL;
  }
  clear_has_my_c();
  return my_c_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignStepBRequest::set_allocated_my_c(::std::string* my_c) {
  if (my_c != NULL) {
    set_has_my_c();
  } else {
    clear_has_my_c();
  }
  my_c_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), my_c);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignStepBRequest.my_c)
}

// -------------------------------------------------------------------

// BytecoinSignStepBResponse

// optional bytes my_ra = 1;
inline bool BytecoinSignStepBResponse::has_my_ra() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinSignStepBResponse::set_has_my_ra() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinSignStepBResponse::clear_has_my_ra() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinSignStepBResponse::clear_my_ra() {
  my_ra_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_my_ra();
}
inline const ::std::string& BytecoinSignStepBResponse::my_ra() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.my_ra)
  return my_ra_.GetNoArena();
}
inline void BytecoinSignStepBResponse::set_my_ra(const ::std::string& value) {
  set_has_my_ra();
  my_ra_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.my_ra)
}
#if LANG_CXX11
inline void BytecoinSignStepBResponse::set_my_ra(::std::string&& value) {
  set_has_my_ra();
  my_ra_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.my_ra)
}
#endif
inline void BytecoinSignStepBResponse::set_my_ra(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_my_ra();
  my_ra_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.my_ra)
}
inline void BytecoinSignStepBResponse::set_my_ra(const void* value, size_t size) {
  set_has_my_ra();
  my_ra_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.my_ra)
}
inline ::std::string* BytecoinSignStepBResponse::mutable_my_ra() {
  set_has_my_ra();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.my_ra)
  return my_ra_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignStepBResponse::release_my_ra() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.my_ra)
  if (!has_my_ra()) {
    return NULL;
  }
  clear_has_my_ra();
  return my_ra_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignStepBResponse::set_allocated_my_ra(::std::string* my_ra) {
  if (my_ra != NULL) {
    set_has_my_ra();
  } else {
    clear_has_my_ra();
  }
  my_ra_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), my_ra);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.my_ra)
}

// optional bytes rb = 2;
inline bool BytecoinSignStepBResponse::has_rb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytecoinSignStepBResponse::set_has_rb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BytecoinSignStepBResponse::clear_has_rb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BytecoinSignStepBResponse::clear_rb() {
  rb_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rb();
}
inline const ::std::string& BytecoinSignStepBResponse::rb() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rb)
  return rb_.GetNoArena();
}
inline void BytecoinSignStepBResponse::set_rb(const ::std::string& value) {
  set_has_rb();
  rb_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rb)
}
#if LANG_CXX11
inline void BytecoinSignStepBResponse::set_rb(::std::string&& value) {
  set_has_rb();
  rb_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rb)
}
#endif
inline void BytecoinSignStepBResponse::set_rb(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rb();
  rb_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rb)
}
inline void BytecoinSignStepBResponse::set_rb(const void* value, size_t size) {
  set_has_rb();
  rb_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rb)
}
inline ::std::string* BytecoinSignStepBResponse::mutable_rb() {
  set_has_rb();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rb)
  return rb_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignStepBResponse::release_rb() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rb)
  if (!has_rb()) {
    return NULL;
  }
  clear_has_rb();
  return rb_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignStepBResponse::set_allocated_rb(::std::string* rb) {
  if (rb != NULL) {
    set_has_rb();
  } else {
    clear_has_rb();
  }
  rb_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rb);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rb)
}

// optional bytes rc = 3;
inline bool BytecoinSignStepBResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BytecoinSignStepBResponse::set_has_rc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BytecoinSignStepBResponse::clear_has_rc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BytecoinSignStepBResponse::clear_rc() {
  rc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rc();
}
inline const ::std::string& BytecoinSignStepBResponse::rc() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rc)
  return rc_.GetNoArena();
}
inline void BytecoinSignStepBResponse::set_rc(const ::std::string& value) {
  set_has_rc();
  rc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rc)
}
#if LANG_CXX11
inline void BytecoinSignStepBResponse::set_rc(::std::string&& value) {
  set_has_rc();
  rc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rc)
}
#endif
inline void BytecoinSignStepBResponse::set_rc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rc();
  rc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rc)
}
inline void BytecoinSignStepBResponse::set_rc(const void* value, size_t size) {
  set_has_rc();
  rc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rc)
}
inline ::std::string* BytecoinSignStepBResponse::mutable_rc() {
  set_has_rc();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rc)
  return rc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinSignStepBResponse::release_rc() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rc)
  if (!has_rc()) {
    return NULL;
  }
  clear_has_rc();
  return rc_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinSignStepBResponse::set_allocated_rc(::std::string* rc) {
  if (rc != NULL) {
    set_has_rc();
  } else {
    clear_has_rc();
  }
  rc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rc);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinSignStepBResponse.rc)
}

// -------------------------------------------------------------------

// BytecoinStartProofRequest

// optional uint32 data_size = 1;
inline bool BytecoinStartProofRequest::has_data_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinStartProofRequest::set_has_data_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinStartProofRequest::clear_has_data_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinStartProofRequest::clear_data_size() {
  data_size_ = 0u;
  clear_has_data_size();
}
inline ::google::protobuf::uint32 BytecoinStartProofRequest::data_size() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinStartProofRequest.data_size)
  return data_size_;
}
inline void BytecoinStartProofRequest::set_data_size(::google::protobuf::uint32 value) {
  set_has_data_size();
  data_size_ = value;
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinStartProofRequest.data_size)
}

// -------------------------------------------------------------------

// BytecoinProofMoreDataRequest

// optional bytes data_chunk = 1;
inline bool BytecoinProofMoreDataRequest::has_data_chunk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytecoinProofMoreDataRequest::set_has_data_chunk() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BytecoinProofMoreDataRequest::clear_has_data_chunk() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BytecoinProofMoreDataRequest::clear_data_chunk() {
  data_chunk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_chunk();
}
inline const ::std::string& BytecoinProofMoreDataRequest::data_chunk() const {
  // @@protoc_insertion_point(field_get:hw.trezor.messages.bytecoin.BytecoinProofMoreDataRequest.data_chunk)
  return data_chunk_.GetNoArena();
}
inline void BytecoinProofMoreDataRequest::set_data_chunk(const ::std::string& value) {
  set_has_data_chunk();
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hw.trezor.messages.bytecoin.BytecoinProofMoreDataRequest.data_chunk)
}
#if LANG_CXX11
inline void BytecoinProofMoreDataRequest::set_data_chunk(::std::string&& value) {
  set_has_data_chunk();
  data_chunk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hw.trezor.messages.bytecoin.BytecoinProofMoreDataRequest.data_chunk)
}
#endif
inline void BytecoinProofMoreDataRequest::set_data_chunk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_chunk();
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hw.trezor.messages.bytecoin.BytecoinProofMoreDataRequest.data_chunk)
}
inline void BytecoinProofMoreDataRequest::set_data_chunk(const void* value, size_t size) {
  set_has_data_chunk();
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hw.trezor.messages.bytecoin.BytecoinProofMoreDataRequest.data_chunk)
}
inline ::std::string* BytecoinProofMoreDataRequest::mutable_data_chunk() {
  set_has_data_chunk();
  // @@protoc_insertion_point(field_mutable:hw.trezor.messages.bytecoin.BytecoinProofMoreDataRequest.data_chunk)
  return data_chunk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BytecoinProofMoreDataRequest::release_data_chunk() {
  // @@protoc_insertion_point(field_release:hw.trezor.messages.bytecoin.BytecoinProofMoreDataRequest.data_chunk)
  if (!has_data_chunk()) {
    return NULL;
  }
  clear_has_data_chunk();
  return data_chunk_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BytecoinProofMoreDataRequest::set_allocated_data_chunk(::std::string* data_chunk) {
  if (data_chunk != NULL) {
    set_has_data_chunk();
  } else {
    clear_has_data_chunk();
  }
  data_chunk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_chunk);
  // @@protoc_insertion_point(field_set_allocated:hw.trezor.messages.bytecoin.BytecoinProofMoreDataRequest.data_chunk)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bytecoin
}  // namespace messages
}  // namespace trezor
}  // namespace hw

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_messages_2dbytecoin_2eproto
